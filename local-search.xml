<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用SendMessage()模拟鼠标操作</title>
    <link href="/2023/08/06/%E4%BD%BF%E7%94%A8SendMessage%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/08/06/%E4%BD%BF%E7%94%A8SendMessage%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="使用SendMessage-模拟鼠标操作">使用SendMessage()模拟鼠标操作</h2><p>在样本分析工作中遇到一个样本，该样本先是打开Windows“运行”窗口，也就是常用的win + R的窗口，然后使用该窗口运行一个.chm文件，这个.chm文件的具体作用尚不清楚，不过杀软报毒，大概是实施二阶段攻击的恶意代码。</p><p>样本中使用SendMessage()来模拟鼠标操作，比较有意思，这里尝试复现一下。</p><p>具体思路是，先运行一个程序，打开该程序的窗口，然后使用FindWindows()找到那个窗口，找到窗口后使用SendMessage()向那个窗口发送消息，模拟鼠标的操作来修改该窗口的状态。</p><blockquote><p>这里介绍一下几个可以用以创建进程的API。</p><p>WinExec(): 这个API是最好使用的，估计这个API的内部是通过ShellExecute()来实现的。</p><p>ShellExecute() &amp; ShellExecuteEx(): 这两个API在MS文档上的描述都是对指定的文件执行一个操作。</p><p>但是这两个函数的区别在于：</p><ul><li>ShellExecuteEx()的返回值是布尔类型，使用这个API创建进程后将会自动调用CloseHandle()关闭进程对应的句柄。</li><li>ShellExecute()的返回值则是新创建的进程的句柄</li></ul><p>这里值得注意的是，ShellExecute()不仅能够对本地的文件执行操作，实际上也能够对URL执行操作。</p><p>CreateProcess(): 这个API就是ShellExecute() &amp; ShellExecuteEx() 这两个API的底层实现。</p><p>另外，如果创建了进程句柄，就必须使用CloseHandle()关闭对应的句柄，因为即使进程终止，系统内核对象中的句柄以及已保存的状态都不会被清空。</p></blockquote><p>虽然思路很清晰，但是具体实施还是比较麻烦的。</p><h3 id="FindWindow">FindWindow</h3><p>首先是需要找到要操作的窗口，使用FindWindow() &amp; FindWindowEx()这两个API。</p><p>FindWindowA() 函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HWND <span class="hljs-title">FindWindowA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCSTR lpClassName,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCSTR lpWindowName</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><p><code>lpClassName</code>：一个字符串指针，用以指定要寻找的窗口的类名</p><p><code>lpWindowName</code>：一个字符串指针，用以指定要寻找的窗口的名称，也即窗口的标题</p><p>返回值：</p><p>对应窗口的句柄。</p><p>The following table describes the system classes that are available for use by all processes.</p><table><thead><tr><th style="text-align:left">Class</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">Button</td><td style="text-align:left">The class for a button.</td></tr><tr><td style="text-align:left">ComboBox</td><td style="text-align:left">The class for a combo box.</td></tr><tr><td style="text-align:left">Edit</td><td style="text-align:left">The class for an edit control.</td></tr><tr><td style="text-align:left">ListBox</td><td style="text-align:left">The class for a list box.</td></tr><tr><td style="text-align:left">MDIClient</td><td style="text-align:left">The class for an MDI client window.</td></tr><tr><td style="text-align:left">ScrollBar</td><td style="text-align:left">The class for a scroll bar.</td></tr><tr><td style="text-align:left">Static</td><td style="text-align:left">The class for a static control.</td></tr></tbody></table><p>The following table describes the system classes that are available only for use by the system.</p><table><thead><tr><th style="text-align:left">Class</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">ComboLBox</td><td style="text-align:left">The class for the list box contained in a combo box.</td></tr><tr><td style="text-align:left">DDEMLEvent</td><td style="text-align:left">The class for Dynamic Data Exchange Management Library (DDEML) events.</td></tr><tr><td style="text-align:left">Message</td><td style="text-align:left">The class for a message-only window.</td></tr><tr><td style="text-align:left">#32768</td><td style="text-align:left">The class for a menu.</td></tr><tr><td style="text-align:left">#32769</td><td style="text-align:left">The class for the desktop window.</td></tr><tr><td style="text-align:left">#32770</td><td style="text-align:left">The class for a dialog box.</td></tr><tr><td style="text-align:left">#32771</td><td style="text-align:left">The class for the task switch window.</td></tr><tr><td style="text-align:left">#32772</td><td style="text-align:left">The class for icon titles.</td></tr></tbody></table><p>这里我们比较关心的窗口类名就是&quot;#32770&quot;也就是系统对话框。</p><p>使用FindWindowA()找到了对应窗口后，我们还需要找到要操作的窗口组件，FindWindowEx()能够完成这个任务。</p><p>FindWindowExA()函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HWND <span class="hljs-title">FindWindowExA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] HWND   hWndParent,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] HWND   hWndChildAfter,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCSTR lpszClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCSTR lpszWindow</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><p><code>hWndParent</code>：使用FindWindowA() 找到的窗口对应的句柄</p><p><code>hWndChildAfter</code>：用以指定从第几个组件开始寻找</p><p><code>lpszClass</code>：用以指定需要寻找的组件的类名</p><p><code>lpszWindow</code>：用以指定需要寻找的组件的名称</p><p>返回值：</p><p>对应窗口的组件的句柄。</p><p>在这篇文章中，需要使用FindWindowEx()找到用以输入命令的ComboBox（ComboBox类的窗口是一种常见的控件，它是组合框控件的实现，通常用于显示一个可编辑的文本框和一个下拉列表框，允许用户从列表中选择项或手动输入文本）以及“确定”按钮。</p><h3 id="SendMessage">SendMessage</h3><p>找到对应窗口的组件后，可以使用SendMessage()来模拟对该组件的操作。</p><p>SendMessage函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LRESULT <span class="hljs-title">SendMessage</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] HWND   hWnd,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] UINT   Msg,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] WPARAM wParam,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] LPARAM lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><p><code>hWnd</code>：SendMessage()作用的窗口组件对应的句柄</p><p><code>Msg</code>：要发送的消息，通常是系统预定义的消息。当然，程序也可以使用自定义的消息。</p><p><code>wParam</code>：Word Parameter，附加于消息的参数</p><p><code>lParam</code>：Long Parameter，附件于消息的参数</p><p>这里介绍一下常用的消息：</p><ul><li>WM_ACTIVATE：用以修改窗口的激活状态，如果窗口处于后台运行，那么这个消息能够激活该窗口；反之，如果窗口目前处于前台，那么这个消息会让窗口转为后台运行。</li><li>WM_SETTEXT：用以设置窗口的文本内容，在参数<code>lParam</code>中指定要设置的文本内容</li><li>WM_LBUTTONDOWN：用以模拟鼠标左键Press效果，参数<code>lParam</code>设为 “MK_BUTTON”，参数<code>wParam</code>用以指定鼠标点击位置</li><li>WM_LBUTTONUP: 用以模拟鼠标左键Release效果，参数设置和WM_LBUTTONDOWN同理。</li></ul><p>有了这些消息类型后，可以模拟出向指定ComboBox输入一条文本内容，然后鼠标点击运行的过程。</p><h3 id="实例">实例</h3><p>这里将会运用同样的原理，使用“运行”窗口运行任务管理器(“taskmgr”)。</p><p>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SHELLEXECUTEINFOA pExecInfo;<br>    HWND hWindow;<br>    HWND hCombo;<br>    HWND hButton;<br><br>    pExecInfo.cbSize = <span class="hljs-built_in">sizeof</span>(SHELLEXECUTEINFOA);<br>    pExecInfo.fMask = SEE_MASK_FLAG_NO_UI;<br>    pExecInfo.lpVerb = <span class="hljs-string">&quot;open&quot;</span>;<br>    pExecInfo.lpFile = <span class="hljs-string">&quot;shell:::&#123;2559a1f3-21d7-11d4-bdaf-00c04f60b9f0&#125;&quot;</span>;<br>    pExecInfo.nShow = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ShellExecuteExA</span>(&amp;pExecInfo))<br>    &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            hWindow = <span class="hljs-built_in">FindWindowA</span>(<span class="hljs-string">&quot;#32770&quot;</span>, <span class="hljs-string">&quot;运行&quot;</span>);<br>            <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">0x5</span>);<br>        &#125; <span class="hljs-keyword">while</span> (!hWindow);<br><br>        <span class="hljs-keyword">if</span> ((hCombo = <span class="hljs-built_in">FindWindowExA</span>(hWindow, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;ComboBox&quot;</span>, <span class="hljs-literal">NULL</span>)) &amp;&amp;<br>            (hButton = <span class="hljs-built_in">FindWindowExA</span>(hWindow, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Button&quot;</span>, <span class="hljs-string">&quot;确定&quot;</span>)))<br>        &#123;<br>            <span class="hljs-built_in">SendMessageA</span>(hCombo, WM_ACTIVATE, <span class="hljs-literal">NULL</span>, (LPARAM)<span class="hljs-string">&quot;taskmgr&quot;</span>);<br>            <span class="hljs-built_in">SendMessageA</span>(hButton, WM_LBUTTONDOWN, MK_LBUTTON, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-built_in">SendMessageA</span>(hButton, WM_LBUTTONUP, MK_LBUTTON, <span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Faild to find the combobox. error code %d.\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to invoke the run window.\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下：</p><p><img src="./image/mouse_clicking_simulation.png" alt="mouse clicking simulation"></p><p>注意上面的代码中，在使用ShellExecuteA()时，将<code>fMask</code>指定为&quot;SEE_MASK_FLAG_NO_UI&quot;，意即不要显示UI界面，即使是错误对话框，使用这个掩码是为了提高隐蔽性。</p><p>但是使用这个掩码后，得到的窗口也是未激活状态的，所以需要使用MS_ACTIVATE来激活窗口。</p><p>另外，在创建进程后，FindWindow()并不能马上找到对应窗口，所以需要将寻找窗口的函数写在一个循环体中。</p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>malware analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举系统进程检测虚拟机环境</title>
    <link href="/2023/08/05/%E6%9E%9A%E4%B8%BE%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%A3%80%E6%B5%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/08/05/%E6%9E%9A%E4%B8%BE%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%A3%80%E6%B5%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="枚举系统进程检测虚拟机环境">枚举系统进程检测虚拟机环境</h2><p>在样本分析的工作中遇到了一个样本，该样本通过枚举系统进程来实现反虚拟机的目的，这里简单记录一下。</p><h3 id="原理">原理</h3><p>因为虚拟机一般都安装了vmtools的，而在虚拟机环境中vmtools对应的进程会在后台运行，该进程对应的可执行文件名称为&quot;vmtoolsd.exe&quot;，所以恶意代码可以通过调用一些API来枚举系统内的所有进程，然后查找是否有vmtools的进程在运行，从而检测当前是否运行在虚拟机环境。</p><p>需要使用到的API：</p><ul><li>CreateToolhelp32Snapshot(): 创建指定进程以及这些进程使用的堆、模块和线程的快照。</li><li>Process32First(): 返回有对应系统快照中遇到的第一个进程的信息。</li><li>Process32Next(): 和Process32First()功能一样，不过能够用于循环枚举。</li></ul><p>借助上面这几个API，其实就很容易通过枚举系统进程来实现反虚拟机，实际上，如果运行权限够高的话，还能够关闭某些进程。</p><h3 id="CreateToolhelp32Snapshot">CreateToolhelp32Snapshot()</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HANDLE <span class="hljs-title">CreateToolhelp32Snapshot</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD dwFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD th32ProcessID</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><p><code>dwFlags</code>：用以指定包含在快照中的范围</p><p><code>th32ProcessID</code>：用以指定某个需要被包含在快照中的进程</p><p>我们这里将<code>dwFlags</code>的取值设置为 TH32CS_SNAPPROCESS(0X2)，即系统内所有的进程都包含在创建的快照中。</p><p>对于第二个参数，其实就不用管，因为 <code>th32ProcessID</code> 只有当 <code>dwFlags</code> 的取值为 { TH32CS_SNAPHEAPLIST**, <strong>TH32CS_SNAPMODULE</strong>, **TH32CS_SNAPMODULE32, TH32CS_SNAPALL} 中的一个时才有效，其他情况下，这个参数都会被忽略。</p><h3 id="Process32First-Next">Process32First&amp;Next()</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">Process32First</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]      HANDLE           hSnapshot,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, out] LPPROCESSENTRY32 lppe</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-function">BOOL <span class="hljs-title">Process32Next</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  HANDLE           hSnapshot,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out] LPPROCESSENTRY32 lppe</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><p><code>hSnapshot</code>：使用CreateToolhelp32Snapshot()创建的快照的句柄</p><p><code>lppe</code>：指向 PROCESSENTRY32 结构类型的指针</p><p>返回值：</p><p>如果成功，则将对应进程的相关信息复制到<code>lppe</code> 指针指向的PROCESSENTRY32结构体变量中，并返回true，否则返回false。</p><p>PROCESSENTRY32</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tagPROCESSENTRY32</span> &#123;<br>  DWORD     dwSize;<br>  DWORD     cntUsage;<br>  DWORD     th32ProcessID;<br>  ULONG_PTR th32DefaultHeapID;<br>  DWORD     th32ModuleID;<br>  DWORD     cntThreads;<br>  DWORD     th32ParentProcessID;<br>  LONG      pcPriClassBase;<br>  DWORD     dwFlags;<br>  CHAR      szExeFile[MAX_PATH];<br>&#125; PROCESSENTRY32;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> <code>dwSize</code> 参数，这个参数表示这个结构体的大小，在调用Process32First()之前, 需要将这个参数设置为<code>sizeof(PROCESSENTRY32)</code>，否则如果不初始化这个参数，Process32First()的调用将会失败.</p><p>这里我们比较关系的成员其实就是<code>szExeFile</code>，这个成员就是进程对应的可执行文件名称。</p><h3 id="实例">实例</h3><p>下面我们将检查系统内所有进程对应的可执行文件的名称来实现虚拟机环境检测。</p><p>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TlHelp32.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hSnapShot;<br>    PROCESSENTRY32 ppe;<br><br>    ppe.dwSize = <span class="hljs-built_in">sizeof</span>(PROCESSENTRY32);<br><br>    <span class="hljs-keyword">if</span> (hSnapShot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0x0</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Process32First</span>(hSnapShot, &amp;ppe)) <br>        &#123;<br>            <span class="hljs-keyword">do</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (ppe.szExeFile[<span class="hljs-number">0x0</span>] == <span class="hljs-string">&#x27;v&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x1</span>] == <span class="hljs-string">&#x27;m&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x2</span>] == <span class="hljs-string">&#x27;t&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x3</span>] == <span class="hljs-string">&#x27;o&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x4</span>] == <span class="hljs-string">&#x27;o&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x5</span>] == <span class="hljs-string">&#x27;l&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x6</span>] == <span class="hljs-string">&#x27;s&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x7</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x8</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0x9</span>] == <span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0xa</span>] == <span class="hljs-string">&#x27;x&#x27;</span> &amp;&amp;<br>                    ppe.szExeFile[<span class="hljs-number">0xb</span>] == <span class="hljs-string">&#x27;e&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Virutal Machine Detected, pid: %d\n&quot;</span>, ppe.th32ProcessID);<br>                    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(hSnapShot, &amp;ppe));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to list the first process.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to create snapshot.\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后在物理机中运行，结果自然是没有检出的，如下：</p><p><img src="./image/vm_detect_on_host.png" alt="vm detect on host"></p><p>再放到虚拟机中运行，结果是检出了虚拟机环境，如下：</p><p><img src="./image/vm_detect_on_vm.png" alt="vm detect on vm"></p><p>可以看到，枚举系统进程来检测虚拟机环境确实是易于实施的。</p><p>此外，这个方法除了能够用于检测虚拟机环境，同样的原理，还可以用以检测当前环境的杀毒软件的情况，比如360Tray.exe等。</p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>malware analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用已知明文攻击破解弱加密算法</title>
    <link href="/2023/08/03/%E4%BD%BF%E7%94%A8%E5%B7%B2%E7%9F%A5%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB%E7%A0%B4%E8%A7%A3%E5%BC%B1%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2023/08/03/%E4%BD%BF%E7%94%A8%E5%B7%B2%E7%9F%A5%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB%E7%A0%B4%E8%A7%A3%E5%BC%B1%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="使用已知明文攻击破解弱加密算法">使用已知明文攻击破解弱加密算法</h2><p>在实习工作中拿到了一个样本，该样本名称为&quot;2023最新财税规定.exe&quot;，SHA256: 36c3405eafd9bdb4c6dd0ca98a2a4779ab34b8777a36b38347316f09109a87e6，该样本在沙箱上检测为木马。</p><p>实际分析发现该样本的攻击行为分为多个阶段，然而本文主要是记录第二阶段所释放的加密文件的破解过程。</p><h3 id="Stage-0-下载器">Stage#0 下载器</h3><p>该样本的第一阶段就是一个下载器，逻辑比较简单，主要就是先检查当前路径，然后自复制并运行，复制完成后从远程FTP服务器上下载第二阶段的恶意代码，加载到内存执行。</p><p><img src="./image/stage1.png" alt="stage1"></p><p>所以这里直接将下载的文件dump下来进行分析。</p><h3 id="Stage-1-文件释放">Stage#1 文件释放</h3><p>到了二阶段，这里着重介绍该样本二阶段释放文件的过程。</p><p>二阶段文件存在释放资源节的行为。</p><p><img src="./image/release_rsrc.png" alt="release_rsrc"></p><p>并且在云沙箱检查到该样本的资源节的熵值偏高，所以怀疑其资源节可能是加了密的。</p><p>使用Resource Hacker打开样本的资源节，可以发现样本的资源节中存放了多个二进制文件。</p><p><img src="./image/resources.png" alt="resources"></p><p>这里面的文件基本都是.dll文件，除了127号文件，可以看出是加密了的。</p><h3 id="密文破解">密文破解</h3><p>因为这个文件是加了密的，并且我没能在二阶段样本中定位到解密的代码（样本使用了某种代码混淆的机制），所以需要先对其进行破解才能进行下一步的分析。</p><p>在破解密文之前，至少需要知道密文加密的方式，其实也就是加密算法，虽然在二阶段没能定位到相关代码。</p><p>但是该样本一阶段有一个解密过程。</p><blockquote><p>样本二阶段在远程主机上是以密文形式保存，所以一阶段将二阶段文件下载下来后还需要进行解密。</p></blockquote><p>所以我们可以猜测这里的密文也是和一阶段的解密流程采用类似的算法。</p><p><img src="./image/decryption.png" alt="decryption"></p><p>可以看到样本使用的解密算法其实和维吉尼亚算法类似，只不过将维吉尼亚算法中移位运算换成了按位异或。</p><p>解密使用的密钥是&quot;Ww6&quot;，尝试用这个密钥解密上面的密文，结果当然是失败了。</p><p>不过，因为这个密文大概率是一个PE格式的文件，所以我们能够知道这个密文中的一部分明文。</p><p>比如从第3个字节开始的前面58个字节的取值为：{0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}，并且在文件第78个字节的偏移处有一个字符串&quot;!This program cannot be run in DOS mode.&quot;。</p><p>有了这部分明文，足够我们进行已知明文攻击了。</p><p>根据上面的加密算法，我们直接将上面这些明文与密文进行异或，可以得到加密这部分明文所使用的密钥。</p><p>异或的结果为：</p><p>{0x34, 0x57, 0x77, 0x33, 0x57, 0x77, 0x3e, 0x57, 0x77, 0x3d, 0x57, 0x77, 0x38, 0x57, 0x77, 0x27, 0x57, 0x77, 0x22, 0x57, 0x77, 0x21, 0x57, 0x77, 0x2c, 0x57, 0x77, 0x2b, 0x57, 0x77, 0x16, 0x57, 0x77, 0x15, 0x57, 0x77, 0x10, 0x57, 0x77, 0x1f, 0x57, 0x77, 0x1a, 0x57, 0x77, 0x19, 0x57, 0x77, 0x04, 0x57, 0x77, 0x03, 0x57, 0x77, 0x0e, 0x57, 0x77, 0x0d, 0x7b, 0x57, 0x77, 0x66, 0x57, 0x77, 0x65, 0x57, 0x77, 0x60, 0x57, 0x77, 0x6f, 0x57, 0x77, 0x6a, 0x57, 0x77, 0x69, 0x57, 0x77, 0x54, 0x57, 0x77, 0x53, 0x57, 0x77, 0x5e, 0x57, 0x77, 0x5d, 0x57, 0x77, 0x58, 0x57, 0x77, 0x47, 0x57, 0x77, 0x42}</p><p>可以看到，这里所使用的密钥周期还是3，但是密钥的第一个字节是在变化的，我们将这些变化的字节单独拿出来看能不能找到一些规律。</p><p><img src="./image/changing_byte.png" alt="changing_byte"></p><p>将这些变化的字节放到一起后，还是能够观察出他们的变化规律的，也就是每16个字节进行一次模0x80加0x50的运算。</p><p>有了这些变化规律后，就可以直接对密文进行破解。</p><p><img src="./image/crack_cipher.png" alt="crack_cipher"></p><p>破解密文后，杀毒软件会对其报毒，说明我们的破解流程还是正确的。</p><p>放到IDA中查看其字符串，可以看到IDA能够加载该文件，并且字符串中也包含一些特征字符串。</p><p><img src="./image/peek_string.png" alt="peek_string"></p><p>这些字符串是Nitol木马家族的特征字符串。</p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>malware analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware虚拟机搭载TOR出网</title>
    <link href="/2023/07/29/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E8%BD%BDTOR%E5%87%BA%E7%BD%91/"/>
    <url>/2023/07/29/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E8%BD%BDTOR%E5%87%BA%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="VMware虚拟机搭载TOR出网">VMware虚拟机搭载TOR出网</h2><p>在样本分析的工作中，通常会存在出网调试的需要，而直接使用本地网络出网会存在被攻击者反向溯源的风险。</p><p>所以一种更加安全可靠的出网方案是走TOR出网，从而实现匿名性。</p><h3 id="TOR-The-Onion-Router">TOR(The Onion Router)</h3><p>TOR是一个开源项目，其目的主要是为用户提供匿名通信服务。TOR通过志愿者运行的服务器（节点）网络运行，这些服务器（节点）通过多层加密传递互联网流量，从而创建多跳、类似洋葱的路由机制。</p><p>当用户使用TOR时，其互联网流量经由一连串的TOR节点路由，而每个节点只知道前一个节点的IP地址，而节点间的通信也采用了多层加密，因此无论是互联网服务提供商(ISP)还是监控机构，都很难以追踪正在传输的数据的来源和目的地。</p><h3 id="环境设置">环境设置</h3><p>TOR项目中提供了TOR浏览器，通过TOR浏览器能够实现匿名上网的目的。</p><p>但是如果想要所有的流量都能够走TOR实现匿名，那么还需要更加复杂的设置。</p><p>不仅如此，如果同时有多个虚拟机需要匿名出网，那么可以将这些虚拟机部署在同一个网段，然后将TOR搭载在出网的网关上，所以需要将TOR服务搭载到一个路由器上。</p><h4 id="pfSense">pfSense</h4><p>pfSense是一款基于FreeBSD操作系统的开源防火墙和路由软件，可以用来构建虚拟环境中的防火墙和路由器。</p><p>所以现在的思路就是，使用pfSense创建一个虚拟路由器，也就是VMware中的一个虚拟机，将虚拟网段中的虚拟机的网关设置为这个虚拟路由器的LAN口地址。随后，再在这个虚拟路由器中搭载TOR服务，使其将流量路由到TOR网络。</p><h2 id="使用pfSense创建TOR网关">使用pfSense创建TOR网关</h2><h3 id="创建pfSense虚拟路由器">创建pfSense虚拟路由器</h3><p>下载pfSense镜像，可以在官网上下载，但是官网上只有最新的Release版本，而本文建议使用pfSense2.5的版本。</p><p>所以可以在Github上找到镜像源：</p><p><a href="https://github.com/CloudSentralDotNet/iso_pfsense">https://github.com/CloudSentralDotNet/iso_pfsense</a></p><p>下载ISO文件后直接在VMware中创建虚拟机，跟创建普通虚拟机没什么区别，只是硬件设置需要注意：</p><ol><li><p>内存256M就够用了</p></li><li><p>需要设置两个网卡(网络适配器)</p><p>一个设置为仅主机模式，用以充当虚拟网络的网关(LAN口)</p><p>一个设置为NAT模式，用以出网，充当路由器的WAN口</p></li></ol><p><img src="./image/hardware_setting.png" alt="hardware_setting"></p><p>在设置好pfSense的硬件设置后，启动虚拟机执行安装程序了。按照默认设置，除了分区需要注意一点，就是使用BIOS分区。</p><p><img src="./image/partition_setting.png" alt="partition setting"></p><p>安装完成后，进入pfSense配置页面。</p><p><img src="./image/pfSense.png" alt="pfSense"></p><p>打开虚拟机网络设置编辑器，检查一下上面的WAN口是不是配在NAT网段的。</p><p><img src="./image/vmware_network.png" alt="vmware_network"></p><p>我这里可以看到WAN口是否属于VMware虚拟机NAT网段的，如果不是的话需要在pfSense配置页面的选项1重新分配网卡。</p><p>网卡分配没问题的话就进入选项2，进行LAN地址的手动分配。</p><p><img src="./image/assign_lan_addr.png" alt="assign lan addr"></p><p>剩下的IPv6的设置不用管，直接ENTER。注意关闭LAN口的dhcp服务，并开启pfSense的网页配置器(webConfigurator)。</p><p><img src="./image/enable_web_conf.png" alt="enable web conf"></p><p>开启了webConfigurator后，就可以直接在浏览器中输入LAN口的地址进行pfSense路由器配置了，路由器配置页的默认账号密码为：admin, pfsense。</p><p><img src="./image/pfSense_webconf.png" alt="pfSenese_webconf"></p><p>根据安装向导进行安装即可，不需要执行什么额外的操作，不过可以修改一下路由器配置页的登录密码。</p><p>完成安装后，可以验证pfSense路由功能。</p><p>开启另一台虚拟机，虚拟机的网络适配器设置为仅主机模式，IP地址与pfSense路由器的LAN口地址属于同一个网段，然后将默认网关以及DNS服务器（pfSense提供DNS解析服务）都设置为pfSense路由器LAN口地址。</p><p><img src="./image/vm_network_setting.png" alt="vm network setting"></p><p>然后用路由器打开一个页面，可以看到是能够连通互联网的。</p><p><img src="./image/routing_success.png" alt="routing success"></p><p>所以可以验证pfSense的路由功能是没有问题的，下一步就是要在pfSense中搭载tor服务了，让pfSense将流量路由到tor网络中。</p><h3 id="在pfSense中搭载TOR服务">在pfSense中搭载TOR服务</h3><p>回到pfSense虚拟机，进入选项14，开启Secure Shell服务。</p><p>然后回到物理机中，开启命令行通过shell登录pfSense虚拟机。登录的账号密码就是pfSense网页配置器的账号密码。ssh登录后通过选项8进入shell页面。</p><p><code>ssh admin@192.168.179.203</code></p><p>后面需要使用FreeBSD系统中的包管理器<code>pkg</code>安装我们所需要的tor包。pfSense中设置了默认的包仓库，名为pfSense和pfSense-core。但是这两个仓库里面都没有我们需要的tor包，tor包在FreeBSD仓库中，这个仓库是默认关闭的。修改pkg的仓库配置文件来开启这个仓库，</p><p><code>vi /usr/local/etc/pkg/repos/FreeBSD.conf</code></p><p><code>vi /usr/local/etc/pkg/repos/pfSense.conf</code></p><p>将FreeBSD: { enabled: no }改为FreeBSD: { enabled: yes }。</p><blockquote><p>使用<code>pkg stat</code>可以查看现在可用的仓库数量以及可下载的包的数量，使用<code>pkg rquery -I tor</code>可以查看tor在已有仓库里的那个仓库中。</p><p>如果想要了解更多pkg相关的内容，可以在google上搜索man pkg导航到FreeBSD官网的pkg手册。</p></blockquote><p>然后输入<code>pkg update</code>更新pkg仓库目录。</p><p>更新完成后，因为我们只需要从FreeBSD仓库中下载我们需要的包，所以可以删除前面修改过的pfSense.conf文件，只保留FreeBSD这一个仓库。使用</p><p><code>pkg install tor</code></p><p>下载tor包。</p><blockquote><p>因为这里并没有进行很细致的pkg配置，所以不删除pfSense仓库的话后面的下载过程中会出现&quot;An error occured while fetching package&quot;。猜测可能是因为pfSense的源在外网，所以无法访问。所以这里直接删除这个仓库，以免出现上面的错误而中断下载进程。</p></blockquote><p><img src="./image/tor_installation.png" alt="tor installation"></p><p>这样就顺利将TOR下载到pfSense中了，接下来就是进行tor配置。</p><p>先删除原来的配置文件：</p><p><code>rm /usr/local/etc/tor/torrc</code></p><p>然后将这个配置文件的内容写为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DNSPort</span> LAN_IP_ADDR:<span class="hljs-number">53</span><br><span class="hljs-attribute">VirtualAddrNetworkIPv4</span> <span class="hljs-number">10.192.0.0</span>/<span class="hljs-number">11</span><br><span class="hljs-attribute">AutomapHostsOnResolve</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">RunAsDaemon</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">TransPort</span> <span class="hljs-number">9040</span><br></code></pre></td></tr></table></figure><p>将上面的LAN_IP_ADDR改成pfSense的LAN口IP地址。</p><p>可以通过命令<code>/usr/local/bin/tor</code>来启动TOR。</p><blockquote><p>如果想要让TOR在pfSense开机时自启动，可以在目录/usr/local/etc/rc.d下创建tor启动脚本，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch /usr/local/etc/rc.d/tor.sh<br>chmod +x /usr/local/etc/rc.d/tor.sh<br>echo &quot;/usr/local/bin/tor&quot; &gt;&gt; /usr/local/etc/rc.d/tor.sh<br></code></pre></td></tr></table></figure><p>pfSense每次开机时就会运行/usr/local/etc/rc.d/tor.sh脚本，从而启动TOR。</p></blockquote><p>随后可以配置防火墙规则，让pfSense将流量路由到TOR网中。</p><p>来到pfSense的网页配置器中，Firewall-&gt;Rules-&gt;LAN，添加下面这段防火墙规则：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Action:</span> Pass<br><span class="hljs-symbol">Interface:</span> LAN<br>Address Family: IPv4<br><span class="hljs-symbol">Protocol:</span> TCP/UDP (DNS can be both)<br><span class="hljs-symbol">Source:</span> LAN net (anything <span class="hljs-keyword">on</span> the LAN)<br><span class="hljs-symbol">Destination:</span> <span class="hljs-type">Single</span> host <span class="hljs-built_in">or</span> <span class="hljs-keyword">alias</span> [IP address <span class="hljs-keyword">of</span> LAN <span class="hljs-keyword">interface</span>]<br>Destination Port Range: DNS (<span class="hljs-number">53</span>)<br></code></pre></td></tr></table></figure><p>上面这段防火墙规则允许pfSense通过TOR网络进行DNS解析，保存后回到防火墙规则列表中，删除下面两条原有的防火墙规则，因为这两条规则会绕过我们刚设置的规则。</p><p><img src="./image/rundunt_rules.png" alt="rundunt rules"></p><p>删除后点击Apply Changes。</p><p>然后关闭pfSense原有的DNS解析服务，Services-&gt;DNS resolver，将Enable选项取消掉，然后save &amp; apply。</p><p>再然后就是设置端口转发(Port Forward)规则，Firewall-&gt;NAT-&gt;Port Forward，添加规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Interface:</span> <span class="hljs-string">LAN</span><br><span class="hljs-attr">Address Family:</span> <span class="hljs-string">IPv4</span><br><span class="hljs-attr">Protocol:</span> <span class="hljs-string">TCP</span><br><span class="hljs-attr">Destination:</span> <span class="hljs-string">LAN</span> <span class="hljs-string">net</span><br><span class="hljs-attr">Destination:</span> <span class="hljs-string">Invert</span> <span class="hljs-string">Match</span> <span class="hljs-string">(ticked)</span><br><span class="hljs-attr">Destination Port Range:</span> <span class="hljs-string">HTTP</span> <span class="hljs-string">(80)</span><br><span class="hljs-attr">Redirect target IP:</span> <span class="hljs-string">Single</span> <span class="hljs-string">host</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-attr">Redirect target port:</span> <span class="hljs-string">Other</span> <span class="hljs-number">9040</span><br></code></pre></td></tr></table></figure><p>上面的规则会将LAN网段上的虚拟机对80端口的访问转发到pfSense上的9040端口上，同理，还可以添加其他端口的转发规则，比如HTTPS(443)，最后Save &amp; apply。</p><h2 id="验证TOR">验证TOR</h2><p>完成了上面所介绍的步骤以后，TOR就算搭载完成了。</p><p>但是需要注意的是，国内的网络并不能直接访问TOR网络，因为这中间隔着一道墙。所以如果想要让pfSense将流量路由到TOR网络的话还需要设置前置代理，主要就是能够让pfSense访问到外网。</p><p>所以完整的虚拟机设置示意图如下：</p><p><img src="./image/deploy_tor.png" alt="deploy_tor"></p><p>所以如果本地网络有socks5服务的话可以在TOR配置文件中添加代理服务。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">Socks5Proxy <span class="hljs-variable constant_">HOST</span><span class="hljs-symbol">:PORT</span><br>Socks5ProxyUsername <span class="hljs-variable constant_">USERNAME</span><br>Socks5ProxyPassword <span class="hljs-variable constant_">PASSWORD</span><br></code></pre></td></tr></table></figure><p>另外，TOR也提供了socks5代理服务，默认在127.0.0.1:9050提供服务，可以在pfSense中使用</p><p><code>curl --socks 127.0.0.1:9050 URL</code></p><p>来进行测试，使用TOR提供的socks5代理服务意味着上面的命令将会走TOR网络访问URL。</p><p>完成配置以后，可以回到前面验证pfSense路由功能的虚拟机中，访问网址：</p><p><a href="https://check.torproject.org/">https://check.torproject.org/</a></p><p>会得到下面的页面：</p><p><img src="./image/tor_success.png" alt="tor success"></p><p>说明虚拟机确实是通过TOR网络访问的该页面。</p><p><em>Ref.</em></p><p><a href="https://catalyst256.medium.com/dark-web-building-a-tor-gateway-7a7dfa45884f">Dark web: Building a Tor Gateway. In some instances it may be necessary… | by Adam Maxwell | Medium</a></p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Malware Analysis Lab07-02 EXP</title>
    <link href="/2023/03/03/Malware-Analysis-Lab07-02-EXP/"/>
    <url>/2023/03/03/Malware-Analysis-Lab07-02-EXP/</url>
    
    <content type="html"><![CDATA[<h2 id="Malware-Analysis-Lab07-02-EXP">Malware Analysis Lab07_02 EXP</h2><p><em>Practical Malware Analysis</em> Lab07_02 Experiment log.</p><p>这个实验的主要内容涉及Windows中的COM(Component Object  Model)相关的接口。</p><h3 id="Introduction-to-COM">Introduction to COM</h3><p>COM被实现成一个客户-服务器架构，客户端是那些使用COM对象的程序，服务器是那些可复用的软件组间，也就是COM本身。</p><p><u>COM对象通过它们的全局唯一标识符(GUID)进行标识，而GUID又由类型标识符(CLSID)以及接口标识符(IID)组成，其中类型标识符用以标识提供COM的程序(服务器)，而接口标识符则用以标识程序提供的接口。</u></p><p>在HKLM\SOFTWARE\Classes\CLSID和HKCU\SOFTWARE\Classes\CLSID注册表键中存储了关于那些代码执行这个COM服务器的信息，比如，在HKLM\SOFTWARE\Classes\CLSID\0002DF01-0000-0000-C000-000000000046的LocalServer32子键中保存了键值C:\Program Files\Internet Explorer\iexplore.exe，这就意味着当CoCreateInstance()函数被调用时要加载的可执行文件。通常，能够在HKLM\SOFTWARE\Classes\Interface目录下找到一些有关于IID的信息，但是也会有例外的情况。</p><p>COM有两种加载方式：#1，以自己的独立进程加载，LocalServer；#2，被作为DLL实现，加载到COM客户端可执行文件的进程空间，InproServer。</p><p>每一个使用COM的线程，必须在调用任何其他COM库函数之前，至少调用一次OleInitialize()和CoInitializeEx()函数，随后，该线程通过调用CoCreateInstance()函数来获取对COM函数的访问，也就是获取服务器所提供的接口的访问。</p><p><code>HRESULT OleInitialize()</code>函数只接受一个参数，这个参数被保留并且必须为NULL，然后这个函数将会初始化COM库。</p><p>用以获取COM函数访问的接口定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">HRESULT <span class="hljs-title function_">CoCreateInstance</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]  REFCLSID  rclsid,</span><br><span class="hljs-params">  [in]  LPUNKNOWN pUnkOuter,</span><br><span class="hljs-params">  [in]  DWORD     dwClsContext,</span><br><span class="hljs-params">  [in]  REFIID    riid,</span><br><span class="hljs-params">  [out] LPVOID    *ppv</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p><strong>这个函数用以创建并默认初始化由参数 CLSID 指定的类的单个对象</strong>。也就是根据参数所提供的CLSID以及IID，输出对应的COM对象。</p><p><code>HRESULT CoCreateInstance()</code>接口所接受的参数的含义如下：</p><ul><li>rclsid：这个参数就是所请求COM对象的CLSID，这个结构体的布局是4, 2, 2, 8字节的数据，其实就对应于HKLM\SOFTWARE\Classes\CLSID\目录下的名称，比如前面提到的iexplorer.exe所对应的CLSID的值就是0002DF01-0000-0000-C000-000000000046，这串数字会被存放到上面提到的这个4, 2, 2, 8布局的结构体中；</li><li>pUnkouter: 如果为 NULL，则表示该对象不是作为聚合的一部分创建的。如果非 NULL，则指向聚合对象的 IUnknown 接口；</li><li>dwClsContext：这个参数用以提示目标COM对象的加载方式，常见的由LocalServer和InproServer两种类型，如果这个COM对象是LocalServer类型的，那么注册表中对应的子键就是LocalServer，对应的键值就是一个EXE文件的路径；如果这个COM对象是LocalServer类型的，那么注册表中对应的子键就是InproServer，对应的键值就是一个DLL文件的路径；</li><li>riid：目标COM对象的IID；</li><li>ppv：当传入这个参数时，需要将其指定为指针的指针，即(void **)&amp;ppv，因为这个值本身是一个指针，而API为了修改这个指针的值，需要传入这个指针的地址；</li></ul><p>这个接口的返回值用以标示函数是否成功执行。但是实际上，我们通常以传入参数ppv指针是否为NULL来判断这个函数是否成功执行。</p><h3 id="int-cdecl-main">int __cdecl main</h3><p>这个实验只有一个主函数，其代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub     esp, 24h<br>push    0               ; pvReserved<br>call    ds:OleInitialize<br>test    eax, eax<br>jl      short loc_401085<br>lea     eax, [esp+24h+ppv] ; eax = esp + 24h<br>push    eax             ; ppv<br>push    offset riid     ; riid<br>push    4               ; dwClsContext<br>push    0               ; pUnkOuter<br>push    offset rclsid   ; rclsid<br>call    ds:CoCreateInstance<br>mov     eax, [esp+24h+ppv]; eax = *(esp + 24h)<br>test    eax, eax<br>jz      short loc_40107F<br>lea     ecx, [esp+24h+pvarg]<br>push    esi<br>push    ecx             ; pvarg<br>call    ds:VariantInit<br>push    offset psz      ; &quot;http://www.malwareanalysisbook.com/ad.h&quot;...<br>mov     [esp+2Ch+var_10], 3<br>mov     [esp+2Ch+var_8], 1<br>call    ds:SysAllocString<br>lea     ecx, [esp+28h+pvarg]<br>mov     esi, eax<br>mov     eax, [esp+28h+ppv]<br>push    ecx<br>lea     ecx, [esp+2Ch+pvarg]<br>mov     edx, [eax]<br>push    ecx<br>lea     ecx, [esp+30h+pvarg]<br>push    ecx<br>lea     ecx, [esp+34h+var_10]<br>push    ecx<br>push    esi<br>push    eax<br>call    dword ptr [edx+2Ch]<br>push    esi             ; bstrString<br>call    ds:SysFreeString<br>pop     esi<br>loc_40107F:<br>call    ds:OleUninitialize<br>loc_401085:<br>xor     eax, eax<br>add     esp, 24h<br>retn<br>_main endp<br></code></pre></td></tr></table></figure><p>这个实验相对比较简单，可以当作是一个COM的应用示例。</p><p>上述的代码还原如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">CLSID rclsid = &#123;<span class="hljs-number">0x2DF01</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &#123;<span class="hljs-number">0xc</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x46</span>&#125;&#125;;<span class="hljs-comment">// CLSID to Internet Explorer</span><br>GUID riid = &#123;<span class="hljs-number">0xD30C1661</span>, <span class="hljs-number">0xCDAF</span>, <span class="hljs-number">0x11D0</span>, &#123;<span class="hljs-number">0x8A</span>, <span class="hljs-number">0x3E</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0xE2</span>, <span class="hljs-number">0x6E</span>&#125;&#125;;<span class="hljs-comment">// IID to IWebBrowser</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    LPVOID *ppv;<br>    VARIANTARG pvarg;<br>    HRESULT hr;<br>    BSTR url;<br>    __int16 bytes[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>    <br>    hr = OleInitialize(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(hr &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    CoCreateInstance(rclsid, <span class="hljs-literal">NULL</span>, CLSCTX_LOCAL_SERVER, riid, (LPVOID **)&amp;ppv);<br>    <span class="hljs-keyword">if</span>(ppv == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        OleUninitialize();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    VariantInit(&amp;pvarg);<span class="hljs-comment">// Initializes a variant.</span><br>    url = SysAllocString(<span class="hljs-string">&quot;http://www.malwareanalysisbook.com/ad.html&quot;</span>);<br>    (*(<span class="hljs-type">void</span> (__stdcall **)(LPVOID, OLECHAR *, __int16 *, VARIANTARG *, VARIANTARG *, VARIANTARG *))(*(_DWORD *)ppv + <span class="hljs-number">44</span>))(<br>    ppv,<br>        url,<br>        bytes,<br>        &amp;pvarg,<br>        &amp;pvarg,<br>        &amp;pvarg,<br>    );<br>    SysFreeString(url);<br>    OleUninitialize();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以注意到上面的代码中，调用COM对象的过程比较复杂。</p><p>而这整个程序其实就是使用Internet Explorer打开一个广告弹窗(<a href="http://www.malwareanalysisbook.com/ad.html">http://www.malwareanalysisbook.com/ad.html</a>)后退出。</p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Malware Analysis Lab07_01 EXP</title>
    <link href="/2023/03/01/Malware-Analysis-Lab07-01-EXP/"/>
    <url>/2023/03/01/Malware-Analysis-Lab07-01-EXP/</url>
    
    <content type="html"><![CDATA[<h2 id="Malware-Analysis-Lab07-01-EXP">Malware Analysis Lab07_01 EXP</h2><p><em>Practical Malware Analysis</em> Lab07_01 Experiment log.</p><p>这个实验主要内容涉及Windows服务以及线程同步。</p><h3 id="int-cdecl-main">int __cdecl main()</h3><p>首先看IDA对main()函数的反汇编结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">int __cdecl main(int argc, const char **argv, const char **envp)<br>_main proc near<br><br>ServiceStartTable[0]= SERVICE_TABLE_ENTRYA ptr -10h<br>ServiceStartTable[1].lpServiceName= dword ptr -8<br>ServiceStartTable[1].lpServiceProc= dword ptr -4<br>argc= dword ptr  4<br>argv= dword ptr  8<br>envp= dword ptr  0Ch<br><br>sub     esp, 10h<br>lea     eax, [esp+10h+ServiceStartTable[0]]<br>mov     [esp+10h+ServiceStartTable[0].lpServiceName], offset aMalservice ; &quot;MalService&quot;<br>push    eax             ; lpServiceStartTable<br>mov     [esp+14h+ServiceStartTable[0].lpServiceProc], offset _service_process<br>mov     [esp+14h+ServiceStartTable[1].lpServiceName], 0<br>mov     [esp+14h+ServiceStartTable[1].lpServiceProc], 0<br>call    ds:StartServiceCtrlDispatcherA<br>push    0<br>push    0<br>call    _service_process<br>add     esp, 18h<br>retn<br>_main endp<br></code></pre></td></tr></table></figure><p>这部分的代码比较简单，可以复现源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    SERVICE_TABLE_ENTRY DispatchTable[] = <br>    &#123; <br>        &#123; MalService, (LPSERVICE_MAIN_FUNCTION) _service_process &#125;, <br>        &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125; <br>    &#125;; <br>    StartServiceCtrlDispatcher(DispatchTable);<br>    <span class="hljs-keyword">return</span> _service_process;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里出现的API就是<code>BOOL StartServiceCtrlDispatcher()</code>，这个API接受一个以NULL作为结束的SERVICE_TABLE_ENTRYA数组，下面将会解释这个API的作用。</p><p>按照微软文档的说法，<strong>这个API会将服务进程的主线程与服务控制管理器(Service Control Manager, SCM)连接</strong>，这使得该线程成为服务进程的服务控制调度器线程(service control dispatcher thread)。</p><p>而这个调度器线程只有当输入参数所指定的所有服务都停止后才会返回，在此之前，将会进入循环以等待对调度表中指定的服务的传入控制请求。</p><p>如何所有在调度表中指定的服务都顺利退出，那么这个API将会返回true，否则将会返回false，并且可以使用GetLastError()以了解详细的错误信息。</p><h3 id="int-service-process">int _service_process()</h3><p>从IDA的反汇编结果来看，这个函数的开头先使用互斥量确保只有一个实例正在运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push    offset Name     ; &quot;HGL345&quot;<br>push    0               ; bInheritHandle<br>push    1F0001h         ; dwDesiredAccess<br>call    ds:OpenMutexA<br>test    eax, eax<br>jz      short loc_401064<br>push    0               ; uExitCode<br>call    ds:ExitProcess<br>loc_401064:<br>push    esi<br>push    offset Name     ; &quot;HGL345&quot;<br>push    0               ; bInitialOwner<br>push    0               ; lpMutexAttributes<br>call    ds:CreateMutexA<br></code></pre></td></tr></table></figure><p>这段可以还原的源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(OpenMutex(MUTEX_ALL_ACCESS, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;HGL345&quot;</span>))<br>    ExitProcess(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span><br>CreateMutex(<span class="hljs-literal">NULL</span>, False, <span class="hljs-string">&quot;HGL345&quot;</span>);<br></code></pre></td></tr></table></figure><p>后面的代码就用创建服务。</p><p>随后，创建SCManager：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push    3               ; dwDesiredAccess<br>push    0               ; lpDatabaseName<br>push    0               ; lpMachineName<br>call    ds:OpenSCManagerA<br></code></pre></td></tr></table></figure><p>这里又出现了一个API <code>SC_HANDLE OpenSCManager()</code>，<strong>这个API的作用是与指定计算机上的服务控制管理器(SCM)建立连接并打开指定的服务控制管理器数据库</strong>。换句话说，这个API的作用就是打开指定的SCM数据库。</p><p>下面的代码将会用于创建一个服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call    ds:GetCurrentProcess<br>lea     eax, [esp+404h+Filename]<br>push    3E8h            ; nSize<br>push    eax             ; lpFilename<br>push    0               ; hModule<br>call    ds:GetModuleFileNameA<br>push    0               ; lpPassword<br>push    0               ; lpServiceStartName<br>push    0               ; lpDependencies<br>push    0               ; lpdwTagId<br>lea     ecx, [esp+414h+Filename]<br>push    0               ; lpLoadOrderGroup<br>push    ecx             ; lpBinaryPathName<br>push    0               ; dwErrorControl<br>push    2               ; dwStartType<br>push    10h             ; dwServiceType<br>push    2               ; dwDesiredAccess<br>push    offset DisplayName ; &quot;Malservice&quot;<br>push    offset DisplayName ; &quot;Malservice&quot;<br>push    esi             ; hSCManager<br>call    ds:CreateServiceA<br></code></pre></td></tr></table></figure><p>这里的GetCurrentProcess()的作用是返回一个处理当前进程的一个伪句柄，但是这里调用这个函数并没有什么用。</p><p>在Windows环境下，想要知道当前进程的可执行文件的路径，可以使用<code>DWORD GetModuleFileNameA([in, optional]HMODULE hModule, [out]LPSTR lpFilename, [in]DWORD nSize)</code>函数，<strong>这个API的作用是检索包含指定模块的文件的完全限定路径，模块必须由当前进程加载。如果传入的指定模块为0，那么这个API将会返回当前进程对应的可执行文件的路径</strong>。</p><p>所以执行完这个函数后，在(esp+404h)位置处的字符数组中将会存放当前进程对应可执行文件的路径。</p><p>然后就是创建一个服务，使用到的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">SC_HANDLE <span class="hljs-title function_">CreateServiceA</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]            SC_HANDLE hSCManager,</span><br><span class="hljs-params">  [in]            LPCSTR    lpServiceName,</span><br><span class="hljs-params">  [in, optional]  LPCSTR    lpDisplayName,</span><br><span class="hljs-params">  [in]            DWORD     dwDesiredAccess,</span><br><span class="hljs-params">  [in]            DWORD     dwServiceType,</span><br><span class="hljs-params">  [in]            DWORD     dwStartType,</span><br><span class="hljs-params">  [in]            DWORD     dwErrorControl,</span><br><span class="hljs-params">  [in, optional]  LPCSTR    lpBinaryPathName,</span><br><span class="hljs-params">  [in, optional]  LPCSTR    lpLoadOrderGroup,</span><br><span class="hljs-params">  [out, optional] LPDWORD   lpdwTagId,</span><br><span class="hljs-params">  [in, optional]  LPCSTR    lpDependencies,</span><br><span class="hljs-params">  [in, optional]  LPCSTR    lpServiceStartName,</span><br><span class="hljs-params">  [in, optional]  LPCSTR    lpPassword</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p><strong>这个API的作用是创建一个服务对象，并且将其添加到有参数指定的SCM数据库中</strong>。这里用来指定SCM数据库的参数就是调用API<code>SC_HANDLE OpenSCManager()</code>所返回的句柄。</p><p>这里对这个API中一些比较重要的参数进行解释。首先是 <em>DWORD dwStartType</em>，这个参数将会指定被创建的服务的类型，这个参数有以下几种可选值：</p><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left"><strong>SERVICE_AUTO_START</strong>0x00000002</td><td style="text-align:left">A service started automatically by the service control manager during system startup.</td></tr><tr><td style="text-align:left"><strong>SERVICE_BOOT_START</strong>0x00000000</td><td style="text-align:left">A device driver started by the system loader. This value is valid only for driver services.</td></tr><tr><td style="text-align:left"><strong>SERVICE_DEMAND_START</strong>0x00000003</td><td style="text-align:left">A service started by the service control manager when a process calls the <a href="https://learn.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-startservicea">StartService</a> function.</td></tr><tr><td style="text-align:left"><strong>SERVICE_DISABLED</strong>0x00000004</td><td style="text-align:left">A service that cannot be started. Attempts to start the service result in the error code <strong>ERROR_SERVICE_DISABLED</strong>.</td></tr><tr><td style="text-align:left"><strong>SERVICE_SYSTEM_START</strong>0x00000001</td><td style="text-align:left">A device driver started by the <strong>IoInitSystem</strong> function. This value is valid only for driver services.</td></tr></tbody></table><p>另一个重要参数是 <em>LPCSTR lpBinaryPathName</em>，这个参数用以指定服务进程对应的二进制文件的完整限定路径，并且也可以通过这个路径向自启动服务传递参数。比如&quot;d:\myshare\myservice.exe arg1 arg2&quot;，这些参数将会被传递到服务的入口点，通常就是main()函数。</p><p>如果这个路径中包含空格，那么需要对于这个进行引用，才能够正确解释，比如&quot;d:\my share\myservice.exe&quot; 应该指定为 ““d:\my share\myservice.exe””。</p><p>所以可以上面的汇编代码完整还原为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">SC_HANDLE schSCManager;<br>SC_HANDLE schService;<br>TCHAR szPath[<span class="hljs-number">0x3e8</span>];<br><br>schSCManager = OpenSCManager( <br><span class="hljs-literal">NULL</span>,                    <span class="hljs-comment">// local computer</span><br>    <span class="hljs-literal">NULL</span>,                    <span class="hljs-comment">// ServicesActive database </span><br>    SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE);<br><br>GetModuleFileName(<span class="hljs-literal">NULL</span>, szPath, <span class="hljs-number">0x3e8</span>);<br><br>schService = CreateService( <br>        schSCManager,              <span class="hljs-comment">// SCM database </span><br>        <span class="hljs-string">&quot;Malservice&quot;</span>,              <span class="hljs-comment">// name of service </span><br>        <span class="hljs-string">&quot;Malservice&quot;</span>,<span class="hljs-comment">// service name to display </span><br>        SC_MANAGER_CREATE_SERVICE,      <span class="hljs-comment">// desired access </span><br>        SERVICE_WIN32_OWN_PROCESS, <span class="hljs-comment">// service type </span><br>        SERVICE_AUTO_START,      <span class="hljs-comment">// start type </span><br>        SERVICE_ERROR_IGNORE,      <span class="hljs-comment">// error control type </span><br>        szPath,                    <span class="hljs-comment">// path to service&#x27;s binary </span><br>        <span class="hljs-literal">NULL</span>,                      <span class="hljs-comment">// no load ordering group </span><br>        <span class="hljs-literal">NULL</span>,                      <span class="hljs-comment">// no tag identifier </span><br>        <span class="hljs-literal">NULL</span>,                      <span class="hljs-comment">// no dependencies </span><br>        <span class="hljs-literal">NULL</span>,                      <span class="hljs-comment">// LocalSystem account </span><br>        <span class="hljs-literal">NULL</span>);                     <span class="hljs-comment">// no password </span><br></code></pre></td></tr></table></figure><p>这里创建的服务类型为SERVICE_WIN32_OWN_PROCESS类型，这种类型的服务将会在.exe文件中保存代码，并且作为一个独立进程运行。</p><p>另外还有一种SERVICE_WIN32_SHARED_PROCESS类型的服务，这种类型的服务将会在.dll文件中保存代码，并且可以在一个共享的进程中组合多个不同的服务。</p><p>还有一种在恶意代码中会见到的服务类型是KERNEL_DRIVER，这种类型的服务将会加载代码到内核中执行。</p><p>后面的代码与Windows中的可等待计时器对象(Waitable Timer Object )相关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xor     edx, edx<br>lea     eax, [esp+404h+FileTime]<br>mov     dword ptr [esp+404h+SystemTime.wYear], edx<br>lea     ecx, [esp+404h+SystemTime]<br>mov     dword ptr [esp+404h+SystemTime.wDayOfWeek], edx<br>push    eax             ; lpFileTime<br>mov     dword ptr [esp+408h+SystemTime.wHour], edx<br>push    ecx             ; lpSystemTime<br>mov     dword ptr [esp+40Ch+SystemTime.wSecond], edx<br>mov     [esp+40Ch+SystemTime.wYear], 834h<br>call    ds:SystemTimeToFileTime<br>push    0               ; lpTimerName<br>push    0               ; bManualReset<br>push    0               ; lpTimerAttributes<br>call    ds:CreateWaitableTimerA<br>push    0               ; fResume<br>push    0               ; lpArgToCompletionRoutine<br>push    0               ; pfnCompletionRoutine<br>lea     edx, [esp+410h+FileTime]<br>mov     esi, eax<br>push    0               ; lPeriod<br>push    edx             ; lpDueTime<br>push    esi             ; hTimer<br>call    ds:SetWaitableTimer<br>push    0FFFFFFFFh      ; dwMilliseconds(-1, INFINITE)<br>push    esi             ; hHandle<br>call    ds:WaitForSingleObject<br>test    eax, eax<br>jnz     short loc_40113B<br></code></pre></td></tr></table></figure><p>这里面先调用了一个<code>BOOL SystemTimeToFileTime()</code>将系统时间(based on Coordinated Universal Time, UTC)转换为文件时间。</p><p>然后创建一个可等待计时器对象，并且设置这个可等待计时器对象并等待这个对象触发。</p><p>这里需要介绍一下设置计时器对象的时间格式，可以分为相对时间和绝对时间，<em>如果传入的参数是负数，那么就意味着这个计时器等待的时间是一个相对时间，将会在由这个参数指定的时间延迟，纳秒为单位，后发送信号；如果传入的参数是FILETIME结构的数据，那么就意味着这个计时器等待的时间是一个绝对时间，只有当系统时间到达这个绝对时间后才会发送信号</em>。</p><blockquote><p>可等待计时器对象：</p><p>线程使用 <code>CreateWaitableTimer()</code> 或 <code>CreateWaitableTimerEx()</code> 函数创建计时器对象。 创建线程指定计时器是手动重置计时器还是同步计时器。 创建线程可以为定时器对象指定一个名称。 其他进程中的线程可以通过在对 <code>OpenWaitableTimer()</code> 函数的调用中指定其名称来打开现有计时器的句柄。 任何具有计时器对象句柄的线程都可以使用其中一个等待函数来等待计时器状态设置为已发出信号。</p><p>当然这里直接使用微软文档中的示例进行介绍会更加直观。</p><p>下面的代码将会创建一个可等待计时器对象，这个对象将会在10秒延迟后发送信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    HANDLE hTimer = <span class="hljs-literal">NULL</span>;<br>    LARGE_INTEGER liDueTime;<br><br>    liDueTime.QuadPart = <span class="hljs-number">-100000000LL</span>;<br><br>    <span class="hljs-comment">// Create an unnamed waitable timer.</span><br>    hTimer = CreateWaitableTimer(<span class="hljs-literal">NULL</span>, TRUE, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == hTimer)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateWaitableTimer failed (%d)\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for 10 seconds...\n&quot;</span>);<br><br>    <span class="hljs-comment">// Set a timer to wait for 10 seconds.</span><br>    <span class="hljs-keyword">if</span> (!SetWaitableTimer(hTimer, &amp;liDueTime, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SetWaitableTimer failed (%d)\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Wait for the timer.</span><br><br>    <span class="hljs-keyword">if</span> (WaitForSingleObject(hTimer, INFINITE) != WAIT_OBJECT_0)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WaitForSingleObject failed (%d)\n&quot;</span>, GetLastError());<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Timer was signaled.\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子中使用<code>BOOL RegisterWaitForSingleObject()</code>接口来判断这个计时器在什么时候发送信号的。（这个API似乎已经过时了）</p></blockquote><p>在这段代码中使用<code>BOOL WaitForSingleObject()</code>接口来判断计时器是否被触发。<strong>这个API的作用就是等待这个计时器对象，直到这个计时器对象发送信号或者设定的等待超时</strong>。如果参数是INFINITE(-1)，那么这个函数将会在计时器发送信号后才会返回。</p><p>这段代码可以还原为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">FILETIME ftFiletime;<br>SYSTEMTIME stSystime;<br>Handle hTimer;<br><br>stSystime.wYear = <span class="hljs-number">0</span>;<br>stSystime.wDayOfWeek = <span class="hljs-number">0</span>;<br>stSystime.wHour = <span class="hljs-number">0</span>;<br>stSystime.wSecond = <span class="hljs-number">0</span>;<br>stSystime.wYear = <span class="hljs-number">2100</span>;<br>SystemTimeToFileTime(&amp;stSystime, &amp;ftFiletime);<br>hTimer = CreateWaitableTimer(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-literal">NULL</span>);<br>SetWaitableTimer(hTimer, &amp;ftFiletime, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(WaitForSingleObject(hTimer, INFINITE) != WAIT_OBJECT_0)<br>&#123;<br>    <span class="hljs-comment">/* WaitForSingleObject failed */</span><br>    Sleep(INFINITE);<span class="hljs-comment">/* -1， Suspend the thread. */</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">while</span>(i--)<br>    CreateThread(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)lpStartAddress, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这段代码的作用就是创建一个可等待计时器对象，并将这个计时器对象的时间设置为绝对时间2100年，在计时器发送信号前会将当前线程挂起。</p><p>后面的代码就是当前线程成功等待计时器发送信号后的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push    edi<br>mov     edi, ds:CreateThread<br>mov     esi, 14h<br><br>loc_401126:<br>push    0               ; lpThreadId<br>push    0               ; dwCreationFlags<br>push    0               ; lpParameter<br>push    offset StartAddress ; lpStartAddress<br>push    0               ; dwStackSize<br>push    0               ; lpThreadAttributes<br>call    edi ; CreateThread<br>dec     esi<br>jnz     short loc_401126<br>pop     edi<br></code></pre></td></tr></table></figure><p>这段代码是一个循环结构，在循环结构体中创建线程，这部分的代码已经在上面的还原了。也就是创建20个立即执行的线程，线程执行的函数由lpStartAddress指定。</p><p>线程所执行的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push    esi<br>push    edi<br>push    0               ; dwFlags<br>push    0               ; lpszProxyBypass<br>push    0               ; lpszProxy<br>push    1               ; dwAccessType<br>push    offset szAgent  ; &quot;Internet Explorer 8.0&quot;<br>call    ds:InternetOpenA<br>mov     edi, ds:InternetOpenUrlA<br>mov     esi, eax<br>loc_40116D:             <br>push    0; dwContext<br>push    80000000h       ; dwFlags<br>push    0               ; dwHeadersLength<br>push    0               ; lpszHeaders<br>push    offset szUrl    ; &quot;http://www.malwareanalysisbook.com&quot;<br>push    esi             ; hInternet<br>call    edi ; InternetOpenUrlA<br>jmp     short loc_40116D<br></code></pre></td></tr></table></figure><p>这段代码的作用就是先初始化一个到互联网的连接，然后进入死循环，不停打开URL&quot;<a href="http://www.malwareanalysisbook.com">http://www.malwareanalysisbook.com</a>&quot;。</p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制加壳与脱壳</title>
    <link href="/2022/12/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/"/>
    <url>/2022/12/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="二进制加壳与脱壳">二进制加壳与脱壳</h2><p>通常恶意软件作者为了避免恶意软件被二进制分析或者逆向研究，会对恶意软件进行加壳保护。</p><blockquote><p>这部分的复现实验出了点问题，暂时搁置。</p></blockquote><p>简单来讲，加壳就是将原来的可执行文件进行压缩或者加密，然后放在另一个可执行文件的数据段中，这个新的可执行文件将会在运行时对原来的可执行文件进行解压缩或者解密，这些操作都是在内存中进行的。然后再将其映射到内存中执行，整个过程都不会在磁盘上写入数据，所以也就无法被静态分析。</p><p>如下图所示：</p><p><img src="./image/protected_binary.png" alt="protected_binary"></p><p>虽然无法通过静态的方法分析原来的二进制文件，但是可以使用动态的方法进行分析。</p><p>注意到加壳后的可执行文件会先在内存中对原来的二进制文件进行解压或者解密后，再将其映射到内存并将控制权转移到二进制文件原来的入口点(Original Entry Point)。</p><p>因此，我们可以在加壳后的可执行文件运行时跟踪其内存读写的操作，进而获取到原来的二进制文件，然后再进一步进行二进制分析。</p><p>想要在程序运行时动态跟踪其内存读写操作，需要使用动态二进制插桩(Dynamic Binary Instrumentation, DBI)技术。</p><h3 id="如何使用Pin">如何使用Pin</h3><p>整个文档将会介绍使用动态二进制插桩平台(DBI Platform) Pin进行一个自动脱壳的实验。</p><p>Pin工具文档：<a href="https://software.intel.com/sites/landingpage/pintool/docs/98650/Pin/doc/html/index.html">Pin: Pin 3.25 User Guide</a></p><p>如果想要了解更多关于二进制插桩的内容，可以参考博客</p><p><a href="https://2hyan9.github.io/2022/10/14/DynamoRIO-Tutorial/">DynamoRIO Tutorial</a></p><p>这篇博客介绍了DynamoRIO的使用方法，DynamoRIO和Pin一样是动态二进制插桩平台，它们的原理基本都是一样的，只是实现细节和优化方法存在差异。</p><p>和DynamoRIO一样，用户在定义DBI工具(client in DynamoRIO, pintools in Pin)时主要定义两部分代码：</p><ol><li>插桩代码：决定在什么地方插入什么代码</li><li>分析代码：在插入点执行的代码</li></ol><p>Pin支持多种细粒度的二进制插桩：</p><ul><li><p>指令插桩：一次仅对二进制文件的一条指令进行检查并插桩，使用&quot;INS_AddInstrumentFunction()&quot;进行注册</p></li><li><p>基本块插桩：对一个基本块进行插桩，也就是为一次对一个基本块调用一次分析函数，使用&quot;TRACE_AddInstrumentFunction()&quot;进行注册。</p><p>Pin中并不能直接对基本块进行插桩，如果要对基本块插桩，就需要使用Trace插桩粒度，然后遍历Trace中的基本块进行分析和插桩</p></li><li><p>函数插桩：当可执行文件首次加载函数时，能够在DBI工具中检查并插桩整个函数的指令，使用&quot;RTN_AddInstrumentFunction()&quot;进行注册</p></li><li><p>IMAGE插桩：DBI工具在一个整个镜像(Image, an entire executable or library)首次被加载到内存时，对其进行检查并插桩，使用&quot;IMG_AddInstrumentFunction()&quot;进行注册</p></li></ul><p>下面将使用一个简单的例子介绍如何使用Pin搭建DBI工具。</p><p>这个例子是官方文档中的例子，对一个程序所执行的指令进行计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (C) 2004-2021 Intel Corporation.</span><br><span class="hljs-comment"> * SPDX-License-Identifier: MIT</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pin.H&quot;</span></span><br><span class="hljs-keyword">using</span> std::cerr;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::ios;<br><span class="hljs-keyword">using</span> std::ofstream;<br><span class="hljs-keyword">using</span> std::string;<br> <br>ofstream OutFile;<br> <br><span class="hljs-comment">// The running count of instructions is kept here</span><br><span class="hljs-comment">// make it static to help the compiler optimize docount</span><br><span class="hljs-type">static</span> UINT64 icount = <span class="hljs-number">0</span>;<br> <br><span class="hljs-comment">// This function is called before every instruction is executed</span><br><span class="hljs-function">VOID <span class="hljs-title">docount</span><span class="hljs-params">()</span> </span>&#123; icount++; &#125;<br> <br><span class="hljs-comment">// Pin calls this function every time a new instruction is encountered</span><br><span class="hljs-function">VOID <span class="hljs-title">Instruction</span><span class="hljs-params">(INS ins, VOID* v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Insert a call to docount before every instruction, no arguments are passed</span><br>    <span class="hljs-built_in">INS_InsertCall</span>(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);<br>&#125;<br> <br><span class="hljs-function">KNOB&lt; string &gt; <span class="hljs-title">KnobOutputFile</span><span class="hljs-params">(KNOB_MODE_WRITEONCE, <span class="hljs-string">&quot;pintool&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;inscount.out&quot;</span>, <span class="hljs-string">&quot;specify output file name&quot;</span>)</span></span>;<br> <br><span class="hljs-comment">// This function is called when the application exits</span><br><span class="hljs-function">VOID <span class="hljs-title">Fini</span><span class="hljs-params">(INT32 code, VOID* v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Write to a file since cout and cerr maybe closed by the application</span><br>    OutFile.<span class="hljs-built_in">setf</span>(ios::showbase);<br>    OutFile &lt;&lt; <span class="hljs-string">&quot;Count &quot;</span> &lt;&lt; icount &lt;&lt; endl;<br>    OutFile.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function">INT32 <span class="hljs-title">Usage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cerr &lt;&lt; <span class="hljs-string">&quot;This tool counts the number of dynamic instructions executed&quot;</span> &lt;&lt; endl;<br>    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::<span class="hljs-built_in">StringKnobSummary</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Initialize pin</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PIN_Init</span>(argc, argv)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Usage</span>();<br> <br>    OutFile.<span class="hljs-built_in">open</span>(KnobOutputFile.<span class="hljs-built_in">Value</span>().<span class="hljs-built_in">c_str</span>());<br> <br>    <span class="hljs-comment">// Register Instruction to be called to instrument instructions</span><br>    <span class="hljs-built_in">INS_AddInstrumentFunction</span>(Instruction, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-comment">// Register Fini to be called when the application exits</span><br>    <span class="hljs-built_in">PIN_AddFiniFunction</span>(Fini, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-comment">// Start the program, never returns</span><br>    <span class="hljs-built_in">PIN_StartProgram</span>();<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要介绍一下Pin中的Knob机制，这个机制允许用户定义的pintool添加一些命令行参数选项，比如在上面的例子中，就使用KNOB机制添加了一个输出文件名称的选项，使用-o选项指定输出文件名称。</p><p>上面例子中演示的pintool的主函数中就是先进行初始化(“PIN_Init()”)，开启输出文件，注册指令级插桩函数，注册用于运行结束时进行输出的终止函数(“PIN_AddFiniFunction()”)，然后启动目标函数(“PIN_StartProgram()”)。</p><p>如果想要了解Pin提供的这些接口的详细用法，可以在官网文档上找到。</p><p>这里定义的插桩过程比较简单，仅仅只是在每条指令之前插入一条调用&quot;docount()&quot;函数的指令，而这个函数不要传递参数。</p><p>如果想要给该函数传递参数，则需要使用Pin中的枚举类型 <a href="https://software.intel.com/sites/landingpage/pintool/docs/98650/Pin/doc/html/group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a> 进行传递，所有的参数都必须以IARG_END类型作为结束，即使上面的例子中没有传递参数，也需要使用IARG_END进行标示。</p><p>安装官网文档上的方法编译运行后的结果如下所示：</p><p><img src="./image/inscount.png" alt="inscount"></p><p>可以看到改工具能够成功对目标程序的指令数进行计数。</p><h3 id="使用Pin实现自动脱壳">使用Pin实现自动脱壳</h3><p>下面将演示如何通过自定义pintool实现由upx加壳工具加壳后的二进制的自动脱壳。</p><p>二进制加壳的具体原理是将原来的二进制文件压缩或者加密，然后放在另一个新的二进制文件的数据段中，这个新的二进制文件的功能仅仅是将原来的二进制文件进行解压缩或者解密，然后将解压缩或者解密后的二进制文件映射到内存中直接执行。所以想要对加壳后的二进制文件进行脱壳，需要对加壳后的二进制文件运行时的内存写和执行的行为进行跟踪。</p><p>UPX是一种常见的二进制加壳工具，使用命令&quot;sudo apt install upx&quot;即可完成安装。下面演示一个加壳后的二进制文件的反汇编结果：</p><p><img src="./image/packed_file.png" alt="packed_file"></p><p>可以看到使用objdump进行反汇编的话将无法获取任何可用的信息，但是加壳后的二进制文件依然能够正常执行。另外，使用strings工具检查加壳后的二进制文件的话将会发现UPX加壳工具的一些提示性的信息，而二进制文件原来的符号信息也被掩藏了。</p><p>所以这里的自动脱壳器就是指令级的插桩，然后检查每条指令的类型，判断其访存类型，而在Pin中可以使用API <a href="https://software.intel.com/sites/landingpage/pintool/docs/98650/Pin/doc/html/group__INS__INSPECTION.html">Pin: Inspection API for IA-32 and Intel® 64 instructions</a>  来检查每条指令的相关信息。</p><p><strong>在Pin中，对于一条写指令，只能在该指令执行之前才能够知道该指令写的地址</strong>，因此有一个插桩点必须是在该指令执行之前，用以记录该指令写的地址。<strong>但是在指令执行之前，也无法获取到该指令写的内容</strong>，所以这里还有一个插桩点就是该指令执行完成之后需要记录该指令写的内容。</p><p>内存写指令前面的插桩点很好解决，但是该指令之后的插桩点相对比较复杂，因为考虑到一点就是该指令指令完之后可能会直接跳转到别的地方，所以直接插在该指令之后的话，可能无法执行插入的指令，因此这里还需要跟踪程序的控制流。</p><p><img src="./image/jump_instruction.png" alt="jump_instruction"></p><p>如上图所示一条跳转指令会将控制流划分为跳转边(Taken edge)和直行边(Fallthrough edge)，<strong>而在Pin中，将非跳转指令后面的指令就是直行边</strong>。所以想要保证每条插入在内存写指令之后的指令能够被执行，需要检查该指令的是否有直行边和跳转边，然后分别对这两条边进行插桩。</p><p>最后，自动脱壳器还需要检查原来的二进制文件的程序入口点(Original Entry Point, OEP)，其思路就是检查程序是否将控制流跳转到曾经写过的地址，并且最后的跳转通常是由间接跳转指令完成的。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pin.H&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_memory_cluster_t</span><br>&#123;<br>    <span class="hljs-type">_memory_cluster_t</span>() : <span class="hljs-built_in">base_addr</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-type">_memory_cluster_t</span>(<span class="hljs-type">uint64_t</span> b, <span class="hljs-type">uint32_t</span> s) : <span class="hljs-built_in">base_addr</span>(b), <span class="hljs-built_in">size</span>(s) &#123;&#125;<br><br>    <span class="hljs-type">uint64_t</span> base_addr;<br>    <span class="hljs-type">uint32_t</span> size;<br>&#125;<span class="hljs-type">memory_cluster_t</span>;<br><br><span class="hljs-type">uint64_t</span> saved_addr = <span class="hljs-number">0</span>;<br><br>std::map&lt; <span class="hljs-type">uint64_t</span>, <span class="hljs-type">uint8_t</span> &gt; shadow_memory;<br>std::vector&lt; <span class="hljs-type">memory_cluster_t</span> &gt; clusters;<br><br>std::ofstream dumped_file;<br><br><span class="hljs-function">KNOB&lt;std::string&gt; <span class="hljs-title">dumped_file_name</span><span class="hljs-params">(KNOB_MODE_WRITEONCE, <span class="hljs-string">&quot;pintool&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;dumped.out&quot;</span>, <span class="hljs-string">&quot;the name of dumped file&quot;</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">in_cluster</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;<br>    std::for_each(clusters.<span class="hljs-built_in">begin</span>(), clusters.<span class="hljs-built_in">end</span>(), <br>        [&amp;result, addr](<span class="hljs-type">memory_cluster_t</span> m)&#123;<br>            <span class="hljs-keyword">if</span>(addr &gt;= m.base_addr &amp;&amp; addr &lt;= (m.base_addr + m.size))<br>                result = <span class="hljs-literal">true</span>;<br>        &#125;<br>    );<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cluster</span><span class="hljs-params">(<span class="hljs-type">memory_cluster_t</span> &amp;c, <span class="hljs-type">uint64_t</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> base_addr = addr;<br>    <span class="hljs-type">uint32_t</span> size = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (shadow_memory.<span class="hljs-built_in">find</span>(base_addr - <span class="hljs-number">1</span>) != shadow_memory.<span class="hljs-built_in">end</span>()) base_addr--;<br>    c.base_addr = base_addr;<br>    <span class="hljs-keyword">while</span> (shadow_memory.<span class="hljs-built_in">find</span>(base_addr + <span class="hljs-number">1</span>) != shadow_memory.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        base_addr++;<br>        size++;<br>    &#125;<br>    c.size = size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">to_save_addr</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    saved_addr = addr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">to_save_value</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(size &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">uint64_t</span> addr = saved_addr;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">uint64_t</span> i = addr; i &lt; addr + size; i++)<br>            <span class="hljs-built_in">PIN_SafeCopy</span>(&amp;shadow_memory[i], (<span class="hljs-type">const</span> <span class="hljs-type">void</span> *)i, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">check_original_entry_point</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> target_addr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">memory_cluster_t</span> c;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">in_cluster</span>(target_addr))<br>    &#123;<br>        <span class="hljs-built_in">set_cluster</span>(c, target_addr);<br>        clusters.<span class="hljs-built_in">push_back</span>(c);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ins_instrument</span><span class="hljs-params">(INS ins, <span class="hljs-type">void</span> *v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">INS_IsMemoryWrite</span>(ins))<br>    &#123; <br>        <span class="hljs-built_in">INS_InsertPredicatedCall</span>(ins, IPOINT_BEFORE, (AFUNPTR)to_save_addr, IARG_MEMORYWRITE_EA, IARG_END);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">INS_HasFallThrough</span>(ins))<br>            <span class="hljs-built_in">INS_InsertPredicatedCall</span>(ins, IPOINT_AFTER, (AFUNPTR)to_save_value, IARG_MEMORYWRITE_SIZE, IARG_END);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">INS_IsValidForIpointTakenBranch</span>(ins))<br>            <span class="hljs-built_in">INS_InsertPredicatedCall</span>(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)to_save_value, IARG_MEMORYWRITE_SIZE, IARG_END);<br>        <br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">INS_IsIndirectControlFlow</span>(ins) &amp;&amp; <span class="hljs-built_in">INS_OperandCount</span>(ins) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">INS_InsertCall</span>(ins, IPOINT_BEFORE, (AFUNPTR)check_original_entry_point, IARG_BRANCH_TARGET_ADDR, IARG_END);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fini</span><span class="hljs-params">(INT32 code, <span class="hljs-type">void</span> *v)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; clusters.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::for_each(clusters.<span class="hljs-built_in">begin</span>(), clusters.<span class="hljs-built_in">end</span>(),<br>        [](<span class="hljs-type">memory_cluster_t</span> c)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;cluster size: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; c.size &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(c.size &gt; <span class="hljs-number">0x1000</span>)<br>            &#123;<br>                <span class="hljs-type">uint32_t</span> i;<br>                <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; c.size; i++)<br>                    dumped_file.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span> *)&amp;shadow_memory[c.base_addr + i], <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint8_t</span>));<br>            &#125;<br>        &#125;<br>    );<br>    dumped_file.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">PIN_Init</span>(argc, argv)) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s &lt;packed file&gt;&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    dumped_file.<span class="hljs-built_in">open</span>(dumped_file_name.<span class="hljs-built_in">Value</span>().<span class="hljs-built_in">c_str</span>(), std::ios_base::binary);<br>   <br>    <span class="hljs-built_in">INS_AddInstrumentFunction</span>(ins_instrument, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">PIN_AddFiniFunction</span>(fini, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">PIN_StartProgram</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个实验暂时是失败的，最后一共得到17个memory_cluster，其大小分别如下：</p><p><img src="./image/unpack_result.png" alt="unpack_result"></p><p>大小只有0x1肯定不是我们要找的cluster，所以在另外两个cluster中找，但是将另外两个cluster分别dump下来后使用strings进行检查，都没有得到想要的结果。</p><p>这个实验暂时搁置。</p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>custom disassemble</title>
    <link href="/2022/11/25/custom-disassemble/"/>
    <url>/2022/11/25/custom-disassemble/</url>
    
    <content type="html"><![CDATA[<h2 id="Custom-Disassemble">Custom Disassemble</h2><p>这里简单介绍一下代码混淆，常见的代码混淆都是基于指令重叠进行的，也就是误导反汇编器将本属于前一条指令的部分解释为当前指令的一部分，这样得到的反汇编结果必然是错误的，比如下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">_start()<br>&#123;<br>    __asm__ <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-string">&quot;jmp antidebug + 1\n&quot;</span></span><br><span class="hljs-params">            <span class="hljs-string">&quot;antidebug:\n&quot;</span></span><br><span class="hljs-params">            <span class="hljs-string">&quot;.short 0xe9\n&quot;</span></span><br><span class="hljs-params">            <span class="hljs-string">&quot;mov $0x31337, %%eax\n&quot;</span></span><br><span class="hljs-params">            :</span><br><span class="hljs-params">            :)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的汇编结果如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Disassembly of section .text:<br><br>0000000000001000 &lt;_start&gt;:<br>    1000:f3 0f 1e fa          endbr64 <br>    1004:55                   push   %rbp<br>    1005:48 89 e5             mov    %rsp,%rbp<br>    1008:eb 01                jmp    100b &lt;antidebug+0x1&gt;<br><br>000000000000100a &lt;antidebug&gt;:<br>    100a:e9 00 b8 37 13       jmp    1337c80f &lt;__bss_start+0x1337880f&gt;<br>    100f:03 00                add    (%rax),%eax<br>    1011:90                   nop<br>    1012:5d                   pop    %rbp<br>    1013:c3                   ret    <br></code></pre></td></tr></table></figure><p>可以看上面的反汇编结果中出现指令重叠的现象，但是从源码可以看到程序是可以正常执行的，只是无法通过常规的反汇编器进行分析。</p><p>这个文档将会介绍如何使用capstone自定义反汇编，准确讲是自定义递归反汇编，从而绕过一些二进制文件的代码混淆。</p><h3 id="反汇编技术概述">反汇编技术概述</h3><p>一般来说，反汇编技术可以分为两类，静态反汇编和动态反汇编。</p><p>静态反汇编是通过静态分析二进制文件以进行反汇编工作，而动态反汇编则是通过跟踪程序运行时所执行的指令以进行反汇编的工作。</p><p>而静态反汇编又可以进一步划分为线性反汇编和递归反汇编。 线性反汇编就是按顺序读取二进制文件然后将二进制文件中的机器码解释为汇编代码，比如objdump就是典型的线性反汇编器；而递归反汇编则可执行文件的程序入口点进行反汇编，然后按照程序的执行流并且以基本块为基本单位进行反汇编，比如IDA Pro中的反汇编就是递归反汇编。</p><blockquote><p>基本块：基本块就是一串指令序列，其中第一条指令是唯一的入口点，而最后一条指令则是唯一的出口点。换句话说，在基本块中除了第一条和最后一条指令就没有其它跳转指令。</p></blockquote><p>显然，静态反汇编无法处理间接跳转的情况，这些问题能够通过动态反汇编解决；而动态反汇编则存在代码覆盖率的问题，也就是动态反汇编无法反汇编程序没有执行的部分，而恶意软件中真正执行破坏的代码都是需要一定的条件进行触发的，这就是所谓的逻辑炸弹。为了解决动态反汇编的代码覆盖率问题，通常使用模糊测试，也就是自动生成一些提高程序分支覆盖的输入。</p><h3 id="Capstone">Capstone</h3><p>Capstone是一个反汇编框架，能够透明地处理大多数流行的指令体系，包括X86. ARM以及MIPS等，提供了一个简单且轻量的API供用户自定义反汇编工具。</p><p>Capstone官网：<a href="https://www.capstone-engine.org/">The Ultimate Disassembly Framework – Capstone – The Ultimate Disassembler</a></p><p>在Capstone的官网文档中找到了下面的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* test.c */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;capstone/capstone.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CODE <span class="hljs-string">&quot;\x55\x48\x8b\x05\xb8\x13\x00\x00&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>csh handle;<br>cs_insn *insn;<br><span class="hljs-type">size_t</span> count;<br><br><span class="hljs-keyword">if</span> (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle) != CS_ERR_OK)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>count = cs_disasm(handle, CODE, <span class="hljs-keyword">sizeof</span>(CODE)<span class="hljs-number">-1</span>, <span class="hljs-number">0x1000</span>, <span class="hljs-number">0</span>, &amp;insn);<br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">size_t</span> j;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; count; j++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%&quot;</span>PRIx64<span class="hljs-string">&quot;:\t%s\t\t%s\n&quot;</span>, insn[j].address, insn[j].mnemonic,<br>insn[j].op_str);<br>&#125;<br><br>cs_free(insn, count);<br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: Failed to disassemble given code!\n&quot;</span>);<br><br>cs_close(&amp;handle);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译该文件：</p><p><code>gcc test.c -lcapstone -o test</code></p><p>这里需要注意&quot;-lcapstone&quot;选项需要放在&quot;test.c&quot;后面，因为链接编辑器进行静态链接时是从左往右进行扫描的，所以文件所依赖的库应该放在文件的右边。</p><p>运行程序得到的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x1000:pushrbp<br>0x1001:movrax, qword ptr [rip + 0x13b8]<br></code></pre></td></tr></table></figure><p>所以可以看到，Capstone以库的形式提供API，通过Capstone提供的API，能够将一系列字节流反汇编为对应指令体系下的汇编代码。</p><p>下面对Capstone的使用进行详细介绍。</p><p>在上面的示例中，首先声明了一个&quot;csh&quot;类型的变量，这就是每一个Capstone提供的API都需要使用到的handle。</p><p>随后由声明了&quot;cs_insn&quot;类型的指针，这个指针所指向的地址将会包含所有已经反汇编完成的指令，后面将会介绍这个指针的结构。</p><p>然后调用了&quot;cs_open()&quot;函数，这个函数将会接受三个变量，指令集体系架构，指令集体系架构的模式，以及一个handle指针。Capstone能够支持的指令集体系架构以及模式以枚举的方式给出，具体如下：</p><p><img src="./image/capstone_archs.png" alt="capstone_archs"></p><p>这个函数相当于进行一些初始化的工作，如果顺利初始化，将会返回&quot;CS_ERR_OK&quot;。</p><p>而执行反汇编行为的函数则是&quot;cs_disasm()&quot;函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">cs_disasm</span><span class="hljs-params">(csh handle, </span><br><span class="hljs-params">                 <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *code, </span><br><span class="hljs-params">                 <span class="hljs-type">size_t</span> code_size, </span><br><span class="hljs-params">                 <span class="hljs-type">uint64_t</span> address, </span><br><span class="hljs-params">                 <span class="hljs-type">size_t</span> count, </span><br><span class="hljs-params">                 cs_insn **insn)</span><br></code></pre></td></tr></table></figure><p>这个函数所接受的第一个参数就是handle；第二参数是将要进行反汇编的字节；第三个参数是将要进行反汇编的字节的长度；第四个参数用于指定第一条指令的地址，在上面的示例中将第一条指令的地址指定为0x1000；第五个参数传入0表示执行反汇编直到所有的字节都已反汇编完成或者遇到无法正确反汇编的指令为止。第六个参数是&quot;cs_insn&quot;指针的地址，&quot;cs_disasm()&quot;函数将会在内存堆区域划分一块区域用以存放所有反汇编的指令，并将这块区域的地址返回到&quot;cs_insn&quot;指针中。</p><p>这个函数的返回值就是正确反汇编的指令数。</p><p>随后通过&quot;cs_insn&quot;指令析出所有已经反汇编指令的信息，&quot;cs_insn&quot;结构的成员如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cs_insn</span> &#123;</span><br><span class="hljs-comment">/// Instruction ID (basically a numeric ID for the instruction mnemonic)</span><br><span class="hljs-comment">/// Find the instruction id in the &#x27;[ARCH]_insn&#x27; enum in the header file</span><br><span class="hljs-comment">/// of corresponding architecture, such as &#x27;arm_insn&#x27; in arm.h for ARM,</span><br><span class="hljs-comment">/// &#x27;x86_insn&#x27; in x86.h for X86, etc...</span><br><span class="hljs-comment">/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF</span><br><span class="hljs-comment">/// <span class="hljs-doctag">NOTE:</span> in Skipdata mode, &quot;data&quot; instruction has 0 for this id field.</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id;<br><br><span class="hljs-comment">/// Address (EIP) of this instruction</span><br><span class="hljs-comment">/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF</span><br><span class="hljs-type">uint64_t</span> address;<br><br><span class="hljs-comment">/// Size of this instruction</span><br><span class="hljs-comment">/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF</span><br><span class="hljs-type">uint16_t</span> size;<br><br><span class="hljs-comment">/// Machine bytes of this instruction, with number of bytes indicated by @size above</span><br><span class="hljs-comment">/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF</span><br><span class="hljs-type">uint8_t</span> bytes[<span class="hljs-number">16</span>];<br><br><span class="hljs-comment">/// Ascii text of instruction mnemonic</span><br><span class="hljs-comment">/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF</span><br><span class="hljs-type">char</span> mnemonic[CS_MNEMONIC_SIZE];<br><br><span class="hljs-comment">/// Ascii text of instruction operands</span><br><span class="hljs-comment">/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF</span><br><span class="hljs-type">char</span> op_str[<span class="hljs-number">160</span>];<br><br><span class="hljs-comment">/// Pointer to cs_detail.</span><br><span class="hljs-comment">/// <span class="hljs-doctag">NOTE:</span> detail pointer is only valid when both requirements below are met:</span><br><span class="hljs-comment">/// (1) CS_OP_DETAIL = CS_OPT_ON</span><br><span class="hljs-comment">/// (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer</span><br><span class="hljs-comment">///     is not NULL, its content is still irrelevant.</span><br>cs_detail *detail;<br>&#125; cs_insn;<br></code></pre></td></tr></table></figure><p>可以一个&quot;cs_insn&quot;结构体就代表一条指令。</p><p>在&quot;cs_insn&quot;指针使用完成后，可以调用&quot;cs_free()&quot;函数释放该指针所指向的内存区域。</p><p>处理完所有的反汇编后，使用&quot;cs_close()&quot;关闭handle。</p><p>如果想要了解更多关于Capstone提供的API信息，可以阅读位于&quot;/usr/include/capstone&quot;目录下的&quot;capstone.h&quot;文件。</p><h4 id="定义线性反汇编工具">定义线性反汇编工具</h4><p>在了解了Capstone所提供的各种API的作用后，很容易自定义一个线性反汇编的工具。</p><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;elf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;capstone/capstone.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">file_handle_t</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *file_name;<br>    <br>    <span class="hljs-type">uint8_t</span> *mem;<br>    Elf64_Ehdr *ehdr;<br>    Elf64_Phdr *phdr;<br>    Elf64_Shdr *shdr;<br>    <span class="hljs-type">char</span> *shrtable;<br><br>    <span class="hljs-type">int</span> text_index;<br>    <span class="hljs-type">int</span> data_index;<br>&#125;<span class="hljs-type">file_handle_t</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s &lt;object file&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">file_handle_t</span> file_handle;<br>    file_handle.file_name = strdup(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-type">int</span> fd = open(file_handle.file_name, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fstat&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    file_handle.mem = mmap(<span class="hljs-literal">NULL</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(file_handle.mem == MAP_FAILED)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(file_handle.mem[<span class="hljs-number">0</span>] != <span class="hljs-number">0x7f</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>((<span class="hljs-type">char</span> *)&amp;file_handle.mem[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ELF&quot;</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is not an ELF file.\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    file_handle.ehdr = (Elf64_Ehdr *)&amp;file_handle.mem[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> ph_offset = file_handle.ehdr-&gt;e_phoff;<br>    file_handle.phdr = (Elf64_Phdr *)&amp;file_handle.mem[ph_offset];<br>    <span class="hljs-type">int</span> sh_offset = file_handle.ehdr-&gt;e_shoff;<br>    file_handle.shdr = (Elf64_Shdr *)&amp;file_handle.mem[sh_offset];<br>    file_handle.shrtable = (<span class="hljs-type">char</span> *)&amp;file_handle.mem[file_handle.shdr[file_handle.ehdr-&gt;e_shstrndx].sh_offset];<br><br>    file_handle.text_index = <span class="hljs-number">0</span>;<br>    file_handle.data_index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; file_handle.ehdr-&gt;e_phnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(file_handle.phdr[i].p_flags == (PF_R | PF_X))<br>            file_handle.text_index = i;<br>        <span class="hljs-keyword">if</span>(file_handle.phdr[i].p_flags == (PF_R | PF_W))<br>            file_handle.data_index = i;<br>    &#125;<br><br>    <span class="hljs-comment">/* disassemble all section that belong to text segment */</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; file_handle.ehdr-&gt;e_shnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>( file_handle.shdr[i].sh_offset &gt;= file_handle.phdr[file_handle.text_index].p_offset &amp;&amp; <br>            file_handle.shdr[i].sh_offset &lt; (file_handle.phdr[file_handle.text_index].p_offset + file_handle.phdr[file_handle.text_index].p_filesz))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;disassembly of %s:\n&quot;</span>, &amp;file_handle.shrtable[file_handle.shdr[i].sh_name]);<br>            csh handle;<br>            cs_insn *insn;<br>            <span class="hljs-type">size_t</span> count;<br>            <span class="hljs-keyword">if</span>(cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle) != CS_ERR_OK)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open capstone.\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            count = cs_disasm(  handle, <br>                                &amp;file_handle.mem[file_handle.shdr[i].sh_offset],<br>                                file_handle.shdr[i].sh_size,<br>                                file_handle.shdr[i].sh_addr,<br>                                <span class="hljs-number">0</span>,<br>                                &amp;insn);<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-type">size_t</span> j;<br>                <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; count; j++)<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%&quot;</span>PRIX64<span class="hljs-string">&quot;: %-16s\t\t%s\n&quot;</span>, insn[j].address, insn[j].mnemonic, insn[j].op_str);<br>                cs_free(insn, count);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to disassemble this section&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>            <br>            cs_close(&amp;handle);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，以节为单位进行反汇编，并且这里只对属于代码段的节进行反汇编。</p><p>使用一个helloworld程序作为测试，输出结果如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">disassembly of .init:<br>0x401000: endbr64<br>0x401004: subrsp, 8<br>0x401008: movrax, qword ptr [rip + 0x2fe9]<br>0x40100F: testrax, rax<br>0x401012: je0x401016<br>0x401014: callrax<br>0x401016: addrsp, 8<br>0x40101A: ret<br><br>...<br><br>disassembly of .fini:<br>0x401154: endbr64<br>0x401158: subrsp, 8<br>0x40115C: addrsp, 8<br>0x401160: ret<br><br></code></pre></td></tr></table></figure><p>为了不影响阅读，这里将中间这段比较长的反汇编结果省略掉了。</p><p>从输出结果来看，Capstone是能够对目标文件进行正确反汇编的。</p><h4 id="定义递归反汇编工具">定义递归反汇编工具</h4><p>接下来将要使用capstone提供的API定义一个递归反汇编工具，递归反汇编相对会比较困难。正如前面所提到的，递归反汇编通过追踪程序的控制流来查找代码，所以我们要在自定义的递归反汇编工具中实现程序控制流跟踪的算法。</p><p>要对程序的控制流进行跟踪，需要更多指令相关的细节信息，比如需要知道哪些指令是控制转移的指令，以及这些指令的操作数。而想要获取到这些信息，需要使用Capstone的detail模式进行反汇编。</p><p>正如前面所提到的，&quot;cs_insn&quot;结构体中包含一个&quot;cs_detail&quot;类型的指针，而&quot;cs_detail&quot;的成员如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cs_detail</span> &#123;</span><br><span class="hljs-type">uint16_t</span> regs_read[<span class="hljs-number">12</span>]; <span class="hljs-comment">///&lt; list of implicit registers read by this insn</span><br><span class="hljs-type">uint8_t</span> regs_read_count; <span class="hljs-comment">///&lt; number of implicit registers read by this insn</span><br><br><span class="hljs-type">uint16_t</span> regs_write[<span class="hljs-number">20</span>]; <span class="hljs-comment">///&lt; list of implicit registers modified by this insn</span><br><span class="hljs-type">uint8_t</span> regs_write_count; <span class="hljs-comment">///&lt; number of implicit registers modified by this insn</span><br><br><span class="hljs-type">uint8_t</span> groups[<span class="hljs-number">8</span>]; <span class="hljs-comment">///&lt; list of group this instruction belong to</span><br><span class="hljs-type">uint8_t</span> groups_count; <span class="hljs-comment">///&lt; number of groups this insn belongs to</span><br><br><span class="hljs-comment">/// Architecture-specific instruction info</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>cs_x86 x86;     <span class="hljs-comment">///&lt; X86 architecture, including 16-bit, 32-bit &amp; 64-bit mode</span><br>...<br>&#125;;<br>&#125; cs_detail;<br></code></pre></td></tr></table></figure><p>使用&quot;cs_detail&quot;类型指针中的&quot;groups_count&quot;以及&quot;groups&quot;成员能够知道当前这条指令属于什么类型，比如下面这几种ISA无关的通用类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">cs_group_type</span> &#123;</span><br>CS_GRP_INVALID = <span class="hljs-number">0</span>,  <span class="hljs-comment">///&lt; uninitialized/invalid group.</span><br>CS_GRP_JUMP,    <span class="hljs-comment">///&lt; all jump instructions (conditional+direct+indirect jumps)</span><br>CS_GRP_CALL,    <span class="hljs-comment">///&lt; all call instructions</span><br>CS_GRP_RET,     <span class="hljs-comment">///&lt; all return instructions</span><br>CS_GRP_INT,     <span class="hljs-comment">///&lt; all interrupt instructions (int+syscall)</span><br>CS_GRP_IRET,    <span class="hljs-comment">///&lt; all interrupt return instructions</span><br>CS_GRP_PRIVILEGE,    <span class="hljs-comment">///&lt; all privileged instructions</span><br>CS_GRP_BRANCH_RELATIVE, <span class="hljs-comment">///&lt; all relative branching instructions</span><br>&#125; cs_group_type;<br></code></pre></td></tr></table></figure><p>如果还想要进一步知道该指令具体是什么指令的话，就需要使用到一些ISA相关的信息，而ISA相关的信息都能在Capstone的目录下找到，比如/usr/include/capstone/X86.h文件中就定义了X86相关的信息。&quot;cs_insn&quot;结构中的&quot;id&quot;成员指明了该指令具体是什么指令，该成员的取值范围能够在ISA相关的头文件中找到，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(insn-&gt;id == X86_INS_JMP)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unconditional jump instruction.\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>而如果想要知道指令的操作数就需要使用&quot;cs_detail&quot;中的&quot;cs_x86&quot;成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cs_x86</span> &#123;</span><br>...<br><span class="hljs-comment">/// Number of operands of this instruction,</span><br><span class="hljs-comment">/// or 0 when instruction has no operand.</span><br><span class="hljs-type">uint8_t</span> op_count;<br><br>cs_x86_op operands[<span class="hljs-number">8</span>];<span class="hljs-comment">///&lt; operands for this instruction.</span><br>&#125; cs_x86;<br></code></pre></td></tr></table></figure><p>其中&quot;cs_x86_op&quot;结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">x86_op_type</span> &#123;</span><br>X86_OP_INVALID = <span class="hljs-number">0</span>, <span class="hljs-comment">///&lt; = CS_OP_INVALID (Uninitialized).</span><br>X86_OP_REG, <span class="hljs-comment">///&lt; = CS_OP_REG (Register operand).</span><br>X86_OP_IMM, <span class="hljs-comment">///&lt; = CS_OP_IMM (Immediate operand).</span><br>X86_OP_MEM, <span class="hljs-comment">///&lt; = CS_OP_MEM (Memory operand).</span><br>&#125; x86_op_type;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cs_x86_op</span> &#123;</span><br>x86_op_type type;<span class="hljs-comment">///&lt; operand type</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>x86_reg reg;  <span class="hljs-comment">///&lt; register value for REG operand</span><br><span class="hljs-type">int64_t</span> imm;<span class="hljs-comment">///&lt; immediate value for IMM operand</span><br>x86_op_mem mem;<span class="hljs-comment">///&lt; base/index/scale/disp value for MEM operand</span><br>&#125;;<br><br><span class="hljs-comment">/// size of this operand (in bytes).</span><br><span class="hljs-type">uint8_t</span> size;<br><br>...<br>&#125; cs_x86_op;<br><br></code></pre></td></tr></table></figure><p>通过&quot;cs_x86_op&quot;结构体中的&quot;imm&quot;成员能够获取到指令的立即数操作数，作为跳转的地址。</p><blockquote><p>注意静态反汇编只能使用立即数作为跳转的地址，因为无法知道寄存器的值。</p></blockquote><p>另外，因为不知道什么时候会遇到下一条控制转移指令，因此无法在&quot;cs_disass()&quot;函数中指定反汇编的字节数，也就无法使用该函数进行反汇编。</p><p>Capstone提供另一个反汇编API，也就是&quot;cs_disass()“的迭代版本，名为&quot;cs_disass_iter()”，该函数一次只会反汇编一条指令。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">cs_disasm_iter</span><span class="hljs-params">(csh handle, </span><br><span class="hljs-params">                    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> **code, </span><br><span class="hljs-params">                    <span class="hljs-type">size_t</span> *size, </span><br><span class="hljs-params">                    <span class="hljs-type">uint64_t</span> *address, </span><br><span class="hljs-params">                    cs_insn *insn)</span><br></code></pre></td></tr></table></figure><p>&quot;cs_disasm_iter()&quot;函数所接受的参数含义与&quot;cs_disasm()&quot;函数所接受的参数的含义是一致的，只不过少了一个&quot;count&quot;参数，并且中间三个参数都指针，<strong><u>这是因为&quot;cs_disasm_iter()&quot;函数会在执行完毕后修改指向代码的指针&quot;code&quot;参数为下一个要反汇编的字节的地址，更新剩余反汇编字节数&quot;size&quot;为减去当前指令字节数后的结果，并且将&quot;address&quot;参数更新为下一条指令的地址。</u></strong></p><p>实际上，&quot;cs_disass_iter()&quot;函数和&quot;cs_disass()&quot;函数在参数&quot;count = 1&quot;时的内部原理是一致的，但是使用&quot;cs_disass_iter()&quot;函数能够更快的运行，因为该函数会对同一块内存区域进行重复使用，而不会调用&quot;malloc()&quot;或者&quot;realloc()&quot;函数进行内存分配。</p><p>递归反汇编的完整代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;elf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;capstone/capstone.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">file_handle_t</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *file_name;<br>    <br>    <span class="hljs-type">uint8_t</span> *mem;<br>    Elf64_Ehdr *ehdr;<br>    Elf64_Phdr *phdr;<br>    Elf64_Shdr *shdr;<br>    <span class="hljs-type">char</span> *shrtable;<br><br>    <span class="hljs-type">int</span> text_index;<br>    <span class="hljs-type">int</span> data_index;<br>&#125;<span class="hljs-type">file_handle_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">address_t</span>&#123;</span><br>    <span class="hljs-type">uint64_t</span> address;<br>    <span class="hljs-type">int</span> layer;<br> &#125; <span class="hljs-type">address_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_SIZE   0x1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_SIZE  0x100</span><br><br><span class="hljs-type">bool</span> is_disasmed[HASH_SIZE] = &#123; <span class="hljs-literal">false</span> &#125;;<br><br><span class="hljs-type">address_t</span> control_flow[QUEUE_SIZE];<br><span class="hljs-type">int</span> head = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_prefix</span><span class="hljs-params">(<span class="hljs-type">int</span> layer)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; layer; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s &lt;object file&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">file_handle_t</span> file_handle;<br>    file_handle.file_name = strdup(argv[<span class="hljs-number">1</span>]);<br>    file_handle.text_index = <span class="hljs-number">0</span>;<br>    file_handle.data_index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> fd = open(file_handle.file_name, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fstat&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    file_handle.mem = mmap(<span class="hljs-literal">NULL</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(file_handle.mem == MAP_FAILED)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(file_handle.mem[<span class="hljs-number">0</span>] != <span class="hljs-number">0x7f</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>((<span class="hljs-type">char</span> *)&amp;file_handle.mem[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ELF&quot;</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is not an ELF file.\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    file_handle.ehdr = (Elf64_Ehdr *)&amp;file_handle.mem[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> ph_offset = file_handle.ehdr-&gt;e_phoff;<br>    file_handle.phdr = (Elf64_Phdr *)&amp;file_handle.mem[ph_offset];<br>    <span class="hljs-type">int</span> sh_offset = file_handle.ehdr-&gt;e_shoff;<br>    file_handle.shdr = (Elf64_Shdr *)&amp;file_handle.mem[sh_offset];<br>    file_handle.shrtable = (<span class="hljs-type">char</span> *)&amp;file_handle.mem[file_handle.shdr[file_handle.ehdr-&gt;e_shstrndx].sh_offset];<br>    <br>    <span class="hljs-type">uint64_t</span> base_address = <span class="hljs-number">0x0</span>;<br>    <span class="hljs-type">uint32_t</span> text_size = <span class="hljs-number">0x0</span>;<br>    <span class="hljs-type">uint64_t</span> text_offset = <span class="hljs-number">0x0</span>;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; file_handle.ehdr-&gt;e_phnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(file_handle.phdr[i].p_flags == (PF_R | PF_X))<br>        &#123;<br>            text_size = file_handle.phdr[i].p_filesz;<br>            text_offset = file_handle.phdr[i].p_offset;<br>            base_address = file_handle.phdr[i].p_vaddr - file_handle.phdr[i].p_offset;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    control_flow[head].address = file_handle.ehdr-&gt;e_entry;<br>    control_flow[head].layer = <span class="hljs-number">0</span>;<br>    head++;<br><br>    csh handle;<br>    <span class="hljs-keyword">if</span>(cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle) != CS_ERR_OK)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open capstone.\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);<br>    cs_insn *insn;<br>    insn = cs_malloc(handle);<br>    <span class="hljs-keyword">if</span>(!insn)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to alloc memory for insn.\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(head != tail)<br>    &#123;<br>        <span class="hljs-type">uint64_t</span> addr = control_flow[tail].address;<br>        <span class="hljs-type">int</span> current_layer = control_flow[tail].layer;<br>        tail = (tail + <span class="hljs-number">1</span>) % QUEUE_SIZE;<br><br>        is_disasmed[addr % HASH_SIZE] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">size_t</span> offset = addr - base_address;<br>        <span class="hljs-type">uint8_t</span> *disasm = &amp;file_handle.mem[offset];<br>        <span class="hljs-type">size_t</span> size = text_offset + text_size - offset;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Branch from 0x%lx:\n&quot;</span>, addr);<br><br>        <span class="hljs-keyword">while</span>(cs_disasm_iter(handle, &amp;disasm, &amp;size, &amp;addr, insn))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(insn-&gt;id == X86_INS_INVALID || insn-&gt;size == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            print_prefix(current_layer);<br>            <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%&quot;</span>PRIX64<span class="hljs-string">&quot;: %-16s\t\t%s\n&quot;</span>, insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);<br>            <span class="hljs-keyword">if</span>(insn-&gt;id == X86_INS_HLT) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">if</span>(insn-&gt;detail-&gt;groups_count &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> n;<br>                <span class="hljs-type">bool</span> is_cft =<span class="hljs-literal">false</span>;<br>                <span class="hljs-type">uint64_t</span> target = <span class="hljs-number">0x0</span>;<br><br>                <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; n &lt; insn-&gt;detail-&gt;groups_count; n++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(insn-&gt;detail-&gt;groups[n] == CS_GRP_CALL || insn-&gt;detail-&gt;groups[n] == CS_GRP_JUMP)<br>                    &#123;<br>                        is_cft = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <br>                <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; is_cft &amp;&amp; n &lt; insn-&gt;detail-&gt;x86.op_count; n++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(insn-&gt;detail-&gt;x86.operands[n].type == X86_OP_IMM)<br>                    &#123;<br>                        target = insn-&gt;detail-&gt;x86.operands[n].imm;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(target &amp;&amp; !is_disasmed[target % HASH_SIZE])<br>                &#123;<br>                    control_flow[head].address = target;<br>                    control_flow[head].layer = current_layer + <span class="hljs-number">1</span>;<br>                    head = (head + <span class="hljs-number">1</span>) % QUEUE_SIZE;<br><br>                    <span class="hljs-keyword">if</span>(insn-&gt;id != X86_INS_JMP &amp;&amp; insn-&gt;id != X86_INS_LJMP)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(!is_disasmed[addr % HASH_SIZE])<br>                        &#123;<br>                            control_flow[head].address = addr;<br>                            control_flow[head].layer = current_layer + <span class="hljs-number">1</span>;<br>                            head = (head + <span class="hljs-number">1</span>) % QUEUE_SIZE;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    cs_free(insn, <span class="hljs-number">1</span>);<br>    cs_close(&amp;handle);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译完成后，使用前面演示代码混淆的例子进行递归反汇编，结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Branch from 0x1000:<br>|-0x1000: endbr64         <br>|-0x1004: push            rbp<br>|-0x1005: mov             rbp, rsp<br>|-0x1008: jmp             0x100b<br><br>Branch from 0x100b:<br>|--0x100B: add             byte ptr [rax + 0x31337], bh<br>|--0x1011: nop             <br>|--0x1012: pop             rbp<br>|--0x1013: ret             <br><br></code></pre></td></tr></table></figure><p>可以看到，这次程序没有从0x100a处开始反汇编，而是从0x100b处开始反汇编，但是依然没有正确反汇编，这是因为Capstone还是将0x100a处的那一个字节作为0x100b处的指令中的一部分了。</p><p>所以还需要定义其他规则让Capstone处理代码重叠问题。</p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp notes for class</title>
    <link href="/2022/11/13/cpp-notes-for-class/"/>
    <url>/2022/11/13/cpp-notes-for-class/</url>
    
    <content type="html"><![CDATA[<h2 id="CPP-notes-for-class">CPP notes for class</h2><p>这个文档主要记录在使用CPP进行面向对象开发时所使用到的CPP中类与继承的相关概念，主要是为了理清几个CPP类与继承中几个比较常见的概念，比如成员初始化列表，访问权限尤其是派生类和基类之间的访问关系，抽象基类和虚函数。</p><p>这里也会放上一些项目实战中的代码。</p><h3 id="场景描述">场景描述</h3><p>因为这个文档主要是记录在我实际的项目开发中的遇到的问题，所以这里有必要对项目开发的场景进行一个简单的介绍。</p><p>项目场景是在Memory trace-driven的缓存仿真器中开发一个预取器。但是这个预取器有多种不同的类型，比如顺序预取器以及步幅预取器。而预取器最终会在缓存模型中进行实例化，所以为了利用C++的类多态特性，很容易想到先开发一个基类: HardwarePrefetcher，然后再由这个基类派生出两个不同的派生类，StridePrefetcher, SequentialPrefetcher，然后再在缓存模型中创建一个基类指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">HardwarePrefetcher *prefetcher;<br></code></pre></td></tr></table></figure><p>因为基类指针能够在不进行类型转换的情况下指向派生类的对象，所以能够让缓存模型在初始化的时候根据配置文件的信息实例化不同的派生类，然后再利用基类指针来调用派生类中的定义的方法。</p><h3 id="成员初始化列表">成员初始化列表</h3><p>基类的代码相对比较简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HardwarePrefetcher</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block_size;<br><br>    <span class="hljs-comment">// the below is some open interfaces</span><br>    <span class="hljs-comment">// &lt;latency, prefetch_addr&gt;</span><br>    std::queue&lt; std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>&gt; &gt; prefetch_queue;<br><br>    <span class="hljs-built_in">HardwarePrefetcher</span>() : <span class="hljs-built_in">block_size</span>(<span class="hljs-number">64</span>) &#123;&#125;<br>    <span class="hljs-built_in">HardwarePrefetcher</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> blcksz) : <span class="hljs-built_in">block_size</span>(blcksz) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_base</span><span class="hljs-params">(<span class="hljs-type">long</span> req_addr, <span class="hljs-type">long</span> pc)</span></span><br><span class="hljs-function">    </span>&#123;<br>      req_addr = req_addr;<br>      pc = pc;<br>    &#125;<br><br>    <span class="hljs-comment">// main mothod of prefetcher</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">tick</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">long</span> req_addr;<br>    <span class="hljs-type">long</span> pc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>成员初始化列表只能用于类的构造函数，通用格式如下：</p><p><em>Constructor(parameter-list) : member1(parameter1), member2(parameter2), … { }</em></p><p>关于成员初始化列表需要注意的是，<strong>成员初始化列表只能用于构造函数，并且构造函数中的参数要么全都有默认值，要么全都没有默认值</strong>。此外，<strong>如果是从基类中继承的保护成员，那么将无法使用成员初始化列表进行初始化</strong>。</p><h3 id="类的继承与访问权限">类的继承与访问权限</h3><p>这里主要讨论公有继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StridePrefetcher</span> : <span class="hljs-keyword">public</span> HardwarePrefetcher<br>&#123;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>基类的公有成员将成为派生类的公有成员；基类的私有成员也会成为派生类的一部分，但是只能通过基类提供的接口进行访问。</p><p>此外，还有一个比较重要的关系是，<u>基类的指针或者引用可以在不进行显示类型转换的情况下，指向派生类的对象。然而，基类的指针或者引用只能调用基类的方法</u>。并且这种关系是单向的，也就是说不能使用派生类的指针或者引用指向基类的对象。</p><p>CPP类的访问权限限定符：</p><table><thead><tr><th>Access</th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>member of the same class</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>member of the derived class</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>not members</td><td>yes</td><td>no</td><td>no</td></tr></tbody></table><p>注意上面的同类的对象也只能访问自己的私有成员。</p><h3 id="虚函数和抽象基类">虚函数和抽象基类</h3><p>前面提到过，在C++中可以在不进行显式类型转换的前提下使用基类的指针或者引用指向派生类的对象，并且能够使用基类指针或引用调用基类中的方法。而另一方面，使用公有继承得到的派生类会继承基类中的公有方法，派生类能够对这些方法进行重写，这就是C++中的类多态(class polymorphism)。</p><p>所以在使用基类指针或引用指向派生类的对象时，如果想要通过基类指针指向派生类中重写的方法，就需要使用虚函数。</p><p>在一个成员函数的声明语句前面使用关键字virtual能够使这个函数称为虚函数。<strong>如果没有使用关键字virtual，程序将根据指针类型或者引用类型选择方法</strong>，也就是使用基类指针或引用将会直接调用基类中的方法；<strong>如果使用了关键字virtual，程序将根据指针或引用所指向的对象的类型来选择方法</strong>，所以如果使用基类指针指向一个派生类对象，将会调用派生类中的方法。</p><p>对于虚函数，需要注意的是，<u>只有函数被重新定义的时候才有必要将其声明为虚函数</u>。注意重新定义并不是指重载，换句话说，<u>虚函数提供了一种重新定义基类函数的方法</u>，重新定义将不只是使用相同参数列表函数声明覆盖基类中的函数声明，无论参数列表是否相同，虚函数都会直接隐藏基类中的方法。不过如果修改了参数列表后，基类指针将无法识别到派生类中重新定义的方法。所以派生类在重新定义虚函数的时候尽量保持参数列表的一致，但是虚函数的返回值可以不必和基类中的保持一致。</p><h4 id="虚函数表">虚函数表</h4><p>如果没有将方法声明为虚函数，那么程序可以直接根据指针类型将函数调用绑定到对应的代码块，这个过程可以在编译时完成，称为<strong>静态绑定</strong>，或者早期绑定。</p><p>如果将方法声明为虚函数，那么只有在运行时才能够知道指针指向的对象类型，所以只能够在程序运行时进行绑定，这个过程为称为<strong>动态绑定</strong>，或者晚期绑定。</p><p>虽然动态绑定能够让程序在运行时进行决策，当时这样的方法需要采取额外的机制来跟踪基类指针指向的对象的类型。</p><p>虚函数表(Virtual Function Table, vtable)就是用于跟踪基类指针指向的对象类型的机制，vtable可以看作是多态类中的一个隐藏静态数据成员(hidden static data member)。每一个多态类的对象都会与一个vtable相关联，即多态类对象中都包含一个隐藏的指针指向vtable。所以程序能够在运行时通过这个指向vtable的指针来判定指针指向的对象的类型。</p><p>如果派生类中对虚函数进行了重新定义，那么该虚函数表中将会保存新函数的地址；如果派生类中没有重新定义虚函数，那么虚函数表中将会保存基类中的定义的函数的地址。调用虚函数时，程序将查看对象中的虚函数表，如果跳转到对应的虚函数表条目。</p><h4 id="纯虚函数和抽象基类">纯虚函数和抽象基类</h4><p>在虚函数声明语句后面加上&quot;=0&quot;可以将其声明为纯虚函数(pure virtual function)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">tick</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>如果类声明中包含纯虚函数，则无法创建这种类型的对象，这样的类只能用作基类，也就是抽象基类(Abstract Bass Class)。可以在方法文件中给出纯虚函数的定义，也可以不给出纯虚函数的定义。</p><p>可以将抽象基类看作是一种必须实施的接口，抽象基类要求具体派生类重新定义其纯虚函数，从而迫使派生类遵循抽象基类设置的接口规则。</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quantitative analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>overview of linux kernel</title>
    <link href="/2022/10/27/overview-of-linux-kernel/"/>
    <url>/2022/10/27/overview-of-linux-kernel/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview-of-linux-kernel">Overview of linux kernel</h2><p>ref. <a href="https://linux-kernel-labs.github.io/refs/heads/master/index.html">linux kernel labs</a></p><h3 id="操作系统基本概念">操作系统基本概念</h3><p>这里先简单回顾一些操作系统中的基本概念，这些内容只是对Linux系统结构的一个提纲挈领的概述，如果想要了解更多的细节，还需要查阅别的资料。</p><h4 id="User-Kernel">User &amp; Kernel</h4><p>首先是用户(User)和内核(Kernel)的概念，内核是操作系统的一部分，以较高的权限运行，而用户则是应用的一部分，以较低的权限运行。</p><p>而<u>用户模式</u>和<u>内核模式</u>则是指处理器的执行模式，<strong>运行在内核模式下的代码能够完全地控制CPU，而运行在用户模式下的代码则存在一定的限制</strong>。</p><p>比如说，在ARM的Cortex-A75处理器下，可以通过CPUECTLR_EL1(CPU Extended Control Register, EL1)寄存器来控制CPU的一些配置，比如开启或关闭缓存预取。而想要访问这个寄存器只需要通过 <code>MRS</code> 汇编指令来读取寄存器，使用 <code>MSR</code> 指令来修改。但是如果在应用中通过内联汇编插入这两条汇编指令后，执行应用的时候会出现&quot;illegal Instruction&quot;错误。这是因为这两条指令只能在CPU的内核模式下执行，而应用中的指令都是CPU在用户模式下执行的。</p><p>而<u>用户空间(User space)</u>和<u>内核空间(Kernel space)</u>则是与内核和用户应用相关的虚拟内存地址空间保护的手段。</p><p><img src="./image/kernel_and_user_space.png" alt="kernel_and_user_space"></p><p>也就是说，内核空间是为内核保留的内存区域，而用户空间则是为特定用户进程保留的内存区域。内核空间的访问是受保护的，用户应用无法直接访问内核空间，而由内核模式执行的代码则能够直接访问用户空间。</p><h4 id="Operating-system-architecture">Operating system architecture</h4><p>下图是一个典型的操作系统结构，操作系统内核负责向多个应用以一种安全且平等的方式向多个应用提供硬件的访问和共享。</p><p><img src="./image/typical_os_architecture.png" alt="typical_os_architecture"></p><p>内核提供了一系列APIs以供用于应用使用，也就是所谓的系统调用。这些API与通常的函数库中的API不同，因为系统调用通常是CPU执行模式从用户模式切换到内核模式的边界。为了提供兼容性，系统调用通常很少改变。</p><p>此外，内核代码在逻辑上也可以划分为内核核心代码和设备驱动代码，设备驱动代码负责提供特定设备的访问，而内核核心代码则更加的通用。当然，内核核心代码也可以进一步划分为多个逻辑子系统，比如文件系统，网络，进程管理等。</p><h4 id="Execution-context">Execution context</h4><p>内核最重要的工作之一就是提供有效的中断服务，而这就与一个特殊的执行上下文相关联。</p><p>当内核收到一个中断时，将会运行在中断上下文(Interrupt Context)中，这包含一个中断处理器，此外还有一些特殊软件也会运行中中断上下文中。在中断上下文中执行的代码通常是CPU在内核模式下执行的，并且内核开发者必须了解这些代码所存在的一些限制，比如不能够调用阻塞函数或者访问用户空间。</p><p>与中断上下文相对应的就是进程上下文(Process Context)。</p><p>进程上下文就是进程当前执行的状态。进程上下文能够进入睡眠状态、可抢占状态，通常用于执行耗时的任务，获取和释放互斥锁。</p><p>中断上下文就是指中断发生，状态/优先级进入中断处理程序，而当前进程停止并保存当前状态直到中断处理完成期间的状态。中断上下文不可进入睡眠状态、不可抢占，通常执行不耗时的任务。</p><h3 id="Linux-kernel概述">Linux kernel概述</h3><p>Linux源码的布局如下：</p><p><img src="./image/linux_src_code_layout.png" alt="linux_src_code_layout"></p><p>这些就是Linux源码顶层文件夹：</p><ul><li>arch - 包含架构特定的代码；每个架构都在特定的子文件夹中实现（例如 arm、arm64、x86）</li><li>block - 包含处理从阻塞设备(block service)读取和写入数据的块子系统代码：创建块 I/O 请求，对其进行调度（使用I/O 调度器），然后合并请求，并通过 I/O 堆栈将它们向下传递到阻塞设备驱动程序</li><li>certs - 使用证书实现对签名验证的支持</li><li>crypto - 各类密码算法的软件实现</li><li>Documentation - 各种子系统的文档、Linux 内核命令行选项、sysfs 文件和格式的描述、设备树绑定</li><li>drivers - 各种设备的驱动程序以及 Linux 驱动程序模型实现（描述驱动程序、设备总线及其连接方式）</li><li>firmware - 各种设备驱动程序使用的二进制或十六进制固件文件</li><li>fs - 虚拟文件系统交换机(Virtual Filesystem Switch)（通用文件系统代码）和各种文件系统驱动程序的所在地</li><li>include - header files</li><li>init - 在系统启动(boot)时所运行的通用初始化代码</li><li>ipc - 实现进程间通信的各类系统调用，比如消息队列(Message queue)、信号量(semaphores)以及共享内存(shared memory)</li><li>kernel - 进程管理的代码（包括实现内核线程和工作队列的代码），调度器，时间管理，通用irq代码以及实现锁的代码</li><li>lib - 各种通用函数，比如排序，校验和，压缩和解压缩以及位图修改</li><li>mm - 内存管理的代码</li><li>net - 各种网络协议栈的实现，包括IPv4和IPv6</li><li>samples - 各种驱动器采样</li><li>scripts - 构建系统(build system)的一部分，用于构建模块的脚本，kconfig Linux 内核配置器，以及各种其他脚本（例如检查补丁是否符合 Linux 内核编码风格的 <a href="http://checkpatch.pl">checkpatch.pl</a>）</li><li>security - Linux 安全模块框架的所在地，它允许扩展默认 (Unix) 安全模型以及实现多个此类扩展，例如 SELinux、smack、apparmor、tomoyo 等。</li><li>sound - ALSA(Advanced Linux Sound System)的所在地</li><li>tools - 各种用于测试或者与内核子系统交互的用户空间工具</li><li>usr - 用于支持在内核镜像中嵌入initrd文件的代码</li><li>virt - KVM管理程序(Kernel Virtual Machine Hypervisor)的所在地</li></ul><p>Linux内核的结构如下图所示：</p><p><img src="./image/linux_kernel_architecture.png" alt="linux_kernel_architecture"></p><p>下面对结构中的一些比较重要的部分进行介绍。</p><h4 id="Arch">Arch</h4><p>这个部分就是特定于系统架构的代码，并且可以进一步划分为特定体系架构的机器特定代码。</p><p>它实现了对架构或机器特定的各种硬件位的访问，例如中断控制器、SMP 控制器、BUS 控制器、异常和中断设置、虚拟内存处理。</p><p>这里也实现了体系架构的优化函数，比如memcpy，字符串操作。</p><h4 id="Process-Management">Process Management</h4><p>Linux实现了Unix中的进程管理标准APIs，比如fork(), exec(), wait()，以及POSIX标准线程。</p><p>然而，在Linux中对于进程和线程的实现与其他内核尤其不同。Linux中没有实现进程或者线程的内部结构，而是使用&quot;struct task_struct&quot;这样的数据结构来描述被称为任务(task)的抽象调度单元。</p><p>在一个task中有指向资源的指针，比如地址空间，文件描述符，IPC id等。</p><p>属于同一个进程的任务的指针将会指向同样的资源，而属于不同进程的任务的指针将会指向不同的资源。这种特性与clone() 和 unshare() 系统调用共同实现了新的功能，也就是命名空间(namespace)。</p><p>命名空间和cgroup(control groups)由共同实现了Linux中的操作系统虚拟化，cgroup 是一种按层次组织进程并以受控和可配置的方式沿层次结构分配系统资源的机制。</p><h4 id="Memory-Management">Memory Management</h4><p>Linux中的内存管理是一个复杂的子系统，主要处理：</p><ul><li>管理物理内存：分配和释放内存</li><li>管理虚拟内存：包括分页，交换，请求分页以及写时复制</li><li>用户服务：用户地址空间的管理，比如mmap(), brk()以及共享内存</li><li>内核服务：SL*B(SLAB, SLOB, SLUB)分配器(allocator)，vmalloc()</li></ul><p>对于Linux中的内存管理，主要接触的还是用户服务这部分的内容。</p><h4 id="阻塞I-O管理">阻塞I/O管理</h4><p>Linux中的阻塞I/O管理框架如下图所示：</p><p><img src="./image/block_IO_management.png" alt="block_IO_management"></p><p>Linux中的阻塞I/O管理子系统主要处理从阻塞I/O设备中读取数据或者向阻塞I/O设备中写入数据，比如创建一个阻塞I/O请求，合并并对这些请求进行排序，然后通过各种I/O调度器来将这些请求调度到阻塞设备的驱动器。</p><h4 id="VFS-Virtual-Filesystem-Switch">VFS(Virtual Filesystem Switch)</h4><p>虚拟文件系统交换机(Virtual Filesystem Switch, VFS)实现了一种通用的文件系统以减少文件系统驱动器的重复，引入了如下几个文件系统抽象：</p><ul><li>inode - 用于描述磁盘上的文件，比如属性，数据块在磁盘上的位置</li><li>dentry - 将inode关联到一个名称上</li><li>file - 用于描述一个已开启的文件的属性，比如文件指针</li><li>superblock - 用于描述格式化的文件系统的属性，比如数据块的数量，数据块的大小，根目录在磁盘上的位置等</li></ul><p>VFS还实现了一个复杂的缓存机制，如下：</p><ul><li>inode cache - 用于缓存文件属性和文件内部的元数据</li><li>dentry cache - 用于缓存文件系统的目录层次结构</li><li>page cache - 用于缓存内存中的文件数据块</li></ul><p><img src="./image/VFS.png" alt="VFS"></p><p>上图描述了VFS的整体框架。</p><h4 id="Networking-Stack">Networking Stack</h4><p><img src="./image/network_stack.png" alt="network stack"></p><p>上图是Linux中的网络协议栈。</p><p>这篇文档主要是对Linux系统的各个组成部分进行一个提纲挈领的概述，如果需要了解更多的细节，还需要进一步查阅资料。</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gnu hash notes</title>
    <link href="/2022/10/17/gnu-hash-notes/"/>
    <url>/2022/10/17/gnu-hash-notes/</url>
    
    <content type="html"><![CDATA[<h2 id="GNU-Hash-notes">GNU Hash notes</h2><p>Linux系统中，在ELF文件的全局偏移表(Global Offset Table, GOT)中的第1个条目用于存放该文件动态段(DT_DYNAMIC)的地址，第2个条目用于存放link_map的地址，第3个条目用于存放链接器(<a href="http://ld.so">ld.so</a>)的地址，准确的说应该是动态链接器_dl_runtime_resolve()函数的地址。</p><p>在进行动态库注入实验时，要使用dlopen()函数在运行时加载一个共享目标，但是一般的宿主程序中都没有调用dlopen()函数，因此也就没有链接libdl共享库，所以无法直接使用dlopen()函数，但是可以使用位于 <a href="http://libc.so">libc.so</a> 中的__libc_dlopen_mode() 函数，该函数的使用方法和dlopen()函数基本是一致的。所以现在的问题是需要得到位于 <a href="http://libc.so">libc.so</a> 中的 __libc_dlopen_mode() 函数的地址。</p><p>通常有两种方法得到该函数的地址。</p><p>第一种方法是直接读取进程中 <a href="http://libc.so">libc.so</a> 对应的地址空间中的内容，然后可以发现这些内容可以使用ELF的格式进行解析。那么就可以找到 <a href="http://libc.so">libc.so</a> 位于进程中的ELF文件头、程序头表，进而得到 <a href="http://libc.so">libc.so</a> 的动态段的地址，然后得到动态符号表(.dynsym)、动态字符表(.dynstr)，然后查询符号表获得__libc_dlopen_mode() 函数的地址。这种方法需要解决的一个问题是如何从目标进程的动态段中的信息确定符号表的条目数，因为进程运行时是不会将节头表加载到内存中的，所以无法直接获取到符号表的条目数。</p><p>对于这个问题，注意到动态符号表(.dynsym)和动态字符表(.dynstr)在内存是邻接着的，这两个表的地址都能够在动态段中找到，所以动态字符表的地址减去动态符号表的地址就是动态符号表的大小，然后再除以sizeof(ElfW_Sym) 就能得到动态符号表的条目数。</p><p>这种比较容易实现，但是在有些 libc 版本中能够实现，但是在有些 libc 版本中却无法搜索到 __libc_dlopen_mode() 这个符号。</p><p>所以通常会采用另一种更加可靠的方法，使用link_map进行查找，而具体的符号查找方法需要使用到GNU hash相关的知识，这篇文章将会介绍如何使用GNU hash进行符号查找。</p><p>首先介绍一下link_map结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> &#123;</span><br>ElfW(Addr) l_addr;  <span class="hljs-comment">/* Base addre where shared object is loaded. */</span><br><span class="hljs-type">char</span> *l_name;  <span class="hljs-comment">/* Absolute pathname where object was found */</span><br>ElfW(Dyn) *l_ld;    <span class="hljs-comment">/* Pointer to Dynamic section of the shared object */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l_next</span>, *<span class="hljs-title">l_prev</span>;</span><br>                        <span class="hljs-comment">/* Chain of loaded objects */</span><br><br>                      <span class="hljs-comment">/* Plus additional fields private to the implementation */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>正如前面提到过的，在ELF文件的GOT中的第二个条目会用于存放link_map结构的地址，用于标示这个ELF文件所加载的共享目标文件，链接器根据这个结构进行符号解析工作。</p><p>上面的这个结构是一个链表结构，所以能够根据GOT中的第二个条目找到ELF文件所加载的所有共享目标。使用ldd命令也能够看到ELF文件所依赖的所有共享目标，注意到链接器实际上也是一个共享目标文件，所以能够在ldd的输出中看到链接器 <a href="http://ld.so">ld.so</a>。</p><p>ref. <a href="https://blogs.oracle.com/solaris/post/gnu-hash-elf-sections">GNU Hash ELF Sections</a></p><h3 id="Hash-function">Hash function</h3><p>GNU hash函数使用的是 DJB(Daniel J Bernstein) 哈希算法，算法的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span><br><span class="hljs-title function_">dl_new_hash</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> h = <span class="hljs-number">5381</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *s; c != <span class="hljs-string">&#x27;\0&#x27;</span>; c = *++s)<br>h = h * <span class="hljs-number">33</span> + c; <span class="hljs-comment">// or h = ((h &lt;&lt; 5) + h) + c;</span><br><br><span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码将接受一个字符串作为参数，然后计算该字符串的DJB哈希值。</p><h3 id="GNU-hash-节">GNU hash 节</h3><p>使用GNU hash，动态符号表将会被划分为两个不同的部分，第一部分是能够从hash表中省略的符号，GNU hash并不会对这一部分施加特定的顺序；第二部分就是能够通过 GNU hash查找到的符号，对于这部分符号，GNU hash将会按照 (hash % nbuckets) 值递增排序，hash值使用上面的方法进行计算，而nbuckets就是哈希桶的数量，哈希桶的数量在GNU hash节中保存。<em>因此位于同一个哈希链中的符号在内存中也是邻接的，提高了空间局部性</em>。</p><p>GNU hash节由下面4个不同的部分组成：</p><ul><li>header</li><li>hash buckets</li><li>hash chains</li><li>布隆过滤器(bloom filter)</li></ul><p>其中header, hash buckets, hash chains都是32-bit的，而布隆过滤器会根据ELFCLASS的不同而有不用的长度，也就是说在ELFCLASS32的ELF文件中布隆过滤器是32-bit的，而在ELFCLASS64的ELF文件中布隆过滤器是64-bit的。所以ELFCLASS32的ELF文件的.gnu.hash在节头表对应条目中的sh_entsize被设为4，而ELFCLASS64的ELF文件的.gnu.hash节的条目长度是不统一的，因此sh_entsize被设为0。</p><h4 id="布隆过滤器">布隆过滤器</h4><p>这里对布隆过滤器进行一个简单的介绍，**布隆过滤器的主要作用是为了快速过滤掉无法在共享目标中找到的符号，从而避免昂贵的符号查找代价。**通常，进程中只有一个对象包含给定符号，跳过所有其他对象的散列操作可以大大加快符号查找速度。</p><p>布隆过滤器是概率性的算法，可能会出现假阳性的判断，也就是说本来不存在于共享目标中的符号可能经过布隆过滤器的判断会认为这个符号在共享目标中，但是不会出现假阴性的判断，也就是说布隆过滤器不会将本来属于共享目标的符号判断为不属于共享目标。</p><p><u>换句话说，布隆过滤可能会出现误判，但是不会拒绝存在于共享目标中的符号。</u></p><p>布隆过滤器由掩码字(maskwords)组成，可以是32bit或者64bit，由ELF文件的类型所决定，掩码字的值是2的整数次幂。GNU hash中使用 k = 2 的布隆过滤器，也就是说需要进行两次独立的哈希计算来查找符号。</p><p><em>根据布隆过滤器中的相关文献，对于较大的 k 值，设计 k 个不同的独立散列函数是困难的。但是对于一些输出比较宽的哈希函数，输出的哈希值的比特段(bit-fields)之间应该几乎没有相关性，所以对于这样的哈希函数，可以通过将其输出哈希值的不同比特段进行分割来得到多个不同的哈希值。</em></p><p>而GNU hash所使用的哈希函数就是具有这样特点的哈希函数，因此，可以使用下面的方法生成布隆过滤器所需要的不同哈希值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">H1 = dl_new_hash(name);<br>H2 = H1 &gt;&gt; shift2;<br></code></pre></td></tr></table></figure><p>链接编辑器(link editor) 会先确定使用多少个掩码字(maskwords)以及上面计算过程中右移的量(shift2)，使用的掩码字越多，.gnu.hash节就会越大，但是布隆过滤器出现假阳性的概率就会越低。而右移量的取值就是哈希表的条目数(dynsymcount - symndx, symndx is the index of 1st dynsym in gnu hash)取2的对数，并且有一个最小值，对于ELFCLASS32为5，对于ELFCLASS64为6。这些值都能够在.gnu.hash节中找到。</p><p>为每一个哈希值设置一个比特，除法运算取高位，取模运算取低位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">N1 = ((H1 / C) % maskwords);<br><span class="hljs-comment">// N1 = ((H1 / C) &amp; (maskwords - 1))</span><br>N2 = ((H2 / C) % maskwords);<br><span class="hljs-comment">// N2 = ((H2 / C) &amp; (maskwords - 1))</span><br><br>B1 = H1 % C;<br>B2 = H2 % C;<br></code></pre></td></tr></table></figure><p>其中 C 为掩码字的大小，以位为单位，也就是对于ELFCLASS32，C = 32；对于ELFCLASS64，C = 64，而maskwords就是布隆过滤器中使用的掩码字的个数，这个数必须是2的整数次幂。</p><p>构建布隆过滤器时填充相应的位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">bloom[N1] |= (<span class="hljs-number">1</span> &lt;&lt; B1);<br>bloom[N2] |= (<span class="hljs-number">1</span> &lt;&lt; B2);<br></code></pre></td></tr></table></figure><p>因此使用布隆过滤器进行判断时，进行下面这样的测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(bloom[N1] &amp; (<span class="hljs-number">1</span> &lt;&lt; B1)) &amp;&amp; (bloom[N2] &amp; (<span class="hljs-number">1</span> &lt;&lt; B2))<br></code></pre></td></tr></table></figure><p><strong>不过在GNU hash中，使用布隆过滤器的一个变体</strong>，只使用布隆过滤器中的一个掩码字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">N = ((H1 / C) % maskwords);<br></code></pre></td></tr></table></figure><p>由哈希值所确定的两个比特则用下面的方法计算，实际上还是没变：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BITMASK = (<span class="hljs-number">1</span> &lt;&lt; (H1 % C)) | (<span class="hljs-number">1</span> &lt;&lt; (H2 % C));<br></code></pre></td></tr></table></figure><p>然后构建布隆过滤器时填充相应的位，这里只填充一个位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bloom[N] |= BITMASK;<br></code></pre></td></tr></table></figure><p>所以在使用布隆过滤器判断共享目标中是否存在这个符号时，进行下面这样的测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(bloom[N] &amp; BITMASK) == BITMASK;<br></code></pre></td></tr></table></figure><p>之所以GNU hash中采用的布隆过滤器只使用一个掩码字，是因为GNU hash的开发者经过测试后发现使用一个掩码字仍然能够保持不错的假阳性比率，并且对缓存也更加友好。</p><h4 id="哈希桶">哈希桶</h4><p>在.gnu.hash节的布局中，位于布隆过滤器之后就是哈希桶值。哈希桶是一个数组，数组元素是32比特字，数组中的每个元素都包含动态符号表中某个符号的索引的低位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(dl_new_hash(symname) % nbuckets) == N<br></code></pre></td></tr></table></figure><p>哈希桶存放着对应符号在动态符号表中的索引值，如果哈希表中没有给定值 N 的符号，则哈希桶元素将包含索引 0。由于动态符号表的索引 0 是保留值，因此该索引不会出现在有效符号中，因此是非歧义的。</p><p>另外，因为动态符号表中的符号是按照哈希值进行排序的，因此 dynsym[buckets[N] + symndx] 所对应的符号就是满足哈希条件的第一个符号。</p><h4 id="哈希值">哈希值</h4><p>在.gnu.hash节中的最后一部分用于存储32-bit的字，也就是动态符号的哈希值，动态符号表中每一个可以使用哈希表查找的符号对有一个对应的哈希值，这些哈希值的前31位直接使用对应符号的哈希值的前31位，而最后一位预留为一个终止位。如果该符号是哈希链中的最后一个符号，那么该符号对应的哈希值的最低位就设为1。</p><h3 id="使用GNU-hash查找符号">使用GNU hash查找符号</h3><p>下面将会通过一个实例展示如何通过GNU Hash查找共享目标中的符号。</p><p>首先需要获取到下面的数据：</p><p>nbuckets: 哈希桶的数量</p><p>symndx: 第一个能够使用hash查找的符号在符号表中的索引</p><p>maskwords: 布隆过滤器中使用的掩码字的个数</p><p>shift_2: 计算第二个哈希值的右移位数</p><p>Bloom word *bloom: 布隆过滤器使用的掩码字数组</p><p>Word *buckets: 哈希桶数组</p><p>Word *hashval: 哈希值数组</p><p>这些数据都存储在目标文件的.gnu.hash节中，可惜 readelf 或者 objdump 工具都无法直接给出上面的这些数据。根据上面所引用的这篇文章来看，ELF文件的.gnu.hash节的布局应该如下所示：</p><ul><li>Header:<ul><li>nbuckets</li><li>symndx</li><li>maskwords</li><li>shift2</li></ul></li><li>Bloom Filter: 也就是布隆过滤器所使用的掩码字数组</li><li>Hash Buckets: 哈希桶数组</li><li>Hash values: 哈希值数组</li></ul><p>这里以ld.so为例，通过 readelf -x 得到.gnu.hash节的内容如下：</p><p><img src="./image/gnu_hash_illustration.png" alt=".gnu.hash_illustration"></p><p>​*注意，使用readelf -x 得到的hex dump内容是以小端排序的，也就是以字节为单位从左到右是低位到高位的。</p><p>在下面的实验中，将会在ld.so中查找符号_dl_allocate_tls符号。</p><p>首先读取ld.so的.gnu.hash节的头部信息如下：</p><p>nbuckets = 0x25, symndx = 0x1, maskwords = 0x04, shift2 = 0x08.</p><p>然后计算符号_dl_open的两个哈希值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> h1 = dl_new_hash(<span class="hljs-string">&quot;_dl_allocate_tls&quot;</span>);<br><span class="hljs-type">uint32_t</span> h2 = h1 &gt;&gt; <span class="hljs-number">0x8</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;H1 -&gt; 0x%x\n&quot;</span>, h1);<span class="hljs-comment">// 0x24bbd60a</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;H2 -&gt; 0x%x\n&quot;</span>, h2);<span class="hljs-comment">// 0x24bbd6</span><br></code></pre></td></tr></table></figure><p>两个哈希值分别为：“0x24bbd60a”, “0x24bbd6”。</p><p>然后计算需要使用哪个布隆掩码字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> N = (h1 / <span class="hljs-number">64</span>) &amp; (<span class="hljs-number">0x4</span> - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;N -&gt; 0x%x\n&quot;</span>, N1);<span class="hljs-comment">// 0x0</span><br></code></pre></td></tr></table></figure><p>得到的结果是使用第0x0个布隆掩码字，从ld.so的.gnu.hash节中找到第0x0个布隆掩码字的取值为&quot;0x1780041808413420&quot;。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint64_t</span> bloom_word = <span class="hljs-number">0x1780041808413420</span>;<br><span class="hljs-type">uint64_t</span> bitmask = (<span class="hljs-number">1</span> &lt;&lt; (h1 % <span class="hljs-number">64</span>)) | (<span class="hljs-number">1</span> &lt;&lt; (h2 % <span class="hljs-number">64</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (bloom_word &amp; bitmask) == bitmask ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>结果是通过了布隆过滤器。</p><p>然后找到哈希值所在的哈希桶：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> nbuckets = <span class="hljs-number">0x25</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\n&quot;</span>, h1 % nbuckets); <span class="hljs-comment">// 0x5</span><br></code></pre></td></tr></table></figure><p>得到的结果是0x5，查看哈希桶buckets[0x05]中的内容，从上图可以看到这个哈希桶中的内容为0x4。也就是符号表dynsym[0x4]对应的符号就是属于该哈希桶的第一个符号。</p><p>然后下一步就是从哈希链中找到对应的符号，哈希链位于.gnu.hash节中的最后一部分，这部分内容保存中动态符号表中每一个可以通过哈希查找的符号的哈希值的前31位。<strong>哈希链中的哈希值的顺序与符号表中的顺序是对应的</strong>，即符号表 ndx 索引处的符号的哈希值在哈希链中的下标为 ndx - symndx。</p><p>因此，将符号表下标初始化为0x04，哈希链下标初始化为 0x04 - symndx = 0x03，然后比对哈希值已经符号表条目的st_name字段，判断是否是我们要找的符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n = <span class="hljs-number">0x4</span>;<br>Elf64_Sym *sym = &amp;dynsym[n];<br><span class="hljs-type">uint32_t</span> *hash_val = &amp;hashval[n - symndx];<br><span class="hljs-keyword">for</span>(h1 &amp;= ~<span class="hljs-number">1</span>; <span class="hljs-number">1</span>; sym++)<br>&#123;<br>    h2 = *hash_val++;<br>    <span class="hljs-keyword">if</span>((h1 == (h2 &amp; ~<span class="hljs-number">1</span>)) &amp;&amp;<br>      !<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;_dl_allocate_tls&quot;</span>, dynstr + sym-&gt;st_name))<br>        <span class="hljs-keyword">return</span> sym;<br>    <span class="hljs-keyword">if</span>(h2 &amp; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的符号表条目中的 st_value 字段取值为 “0x147a0”，使用nm来验证这一结果：</p><p><img src="./image/symbol_verification.png" alt="symbol_verification"></p><p>可以看到能够正确地获取到dl_allocate_tls符号对应的符号表条目。</p>]]></content>
    
    
    <categories>
      
      <category>experiment log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DynamoRIO Tutorial</title>
    <link href="/2022/10/14/DynamoRIO-Tutorial/"/>
    <url>/2022/10/14/DynamoRIO-Tutorial/</url>
    
    <content type="html"><![CDATA[<h2 id="DynamoRIO-Tutorial">DynamoRIO Tutorial</h2><p>这个文档是一个DynamoRIO的使用教程。DynamoRIO是一个动态二进制插桩平台(Dynamic Binary Instrumentation Platform)，可以向用户提供一些API以实现一些用户自定义的插桩工具。虽然在DynamoRIO的官网上Available Tools目录下有一些现成的插桩工具，但是在有些场景下需要使用自定义的插桩，而这个文档将会介绍如何使用DynamoRIO来搭建自定义的插桩工具。</p><h3 id="DBI-Dynamic-Binary-Instrumentation">DBI(Dynamic Binary Instrumentation)</h3><p>这里先介绍一下什么是动态二进制插桩，先从插桩开始介绍。</p><p>所谓插桩(Instrumenting)其实就是修改二进制文件的内容，在现有的二进制程序中的某些位置插入新的代码，然后以某种方式来观察或者修改二进制程序的行为。插入新的代码的位置被称为插桩点(instrumentation point)，添加的新代码就被称为插桩代码(instrumentation code)。</p><p>比如，假设你想知道一个二进制程序中调用最频繁的函数，以便对其进行着重优化。那么为了找到这个调用最频繁的函数，可以对所有的call指令进行插桩，也就是在所有的call指令之前插入新的指令，这些指令用以记录调用的目标。</p><p>二进制插桩分为两种类型，静态二进制插桩(Static Binary Instrumentation, SBI)与动态二进制插桩(Dynamic Binary Instrumentation, DBI)。有一些资料会将源码插桩，比如在源码中添加一条printf()语句来显示当前变量的取值，也归为一种类型。</p><p>这里简单介绍一下静态插桩方法，静态插桩就是对二进制文件进行插桩，在二进制文件中直接添加插桩指令以达到插桩的目的。</p><p>但是静态插桩面临着许多问题，首先，如果直接在二进制文件的任意一个位置中插入新的指令，那么就会改变二进制文件原有代码的偏移量，函数调用就会指向错误的地址，被插桩的程序也就无法正常执行。</p><p>上面介绍的问题是静态插桩需要解决的一个基本问题，也就是说必须要能够解决上面的问题才能使一个静态插桩工具正常运行。除了这个问题，静态插桩还无法解决间接跳转，考虑下面这样的指令：<code>jmp *%rax</code>，程序跳转到寄存器%rax中保存的地址中执行。在静态插桩的时候，无法知道寄存器%rax中存放的到底是什么地址，那么也就无法继续跟踪程序的控制流。</p><p>而且上面所讨论的静态插桩的问题都是基于正确反汇编的前提下的，如果这个前提不成立，那么进行任何插桩都会破坏原有的二进制文件。</p><p>所以静态插桩的方法的可靠性存在着很大的问题，目前也没有一种公开的且高效的SBI技术。</p><p>相对而言，动态插桩就能够很好地解决前面所讨论的问题：监视程序执行的指令流，在程序执行时进行插桩，能够有效地跟踪程序的执行过程。</p><p>下图是动态二进制插桩工具的整体框架，目前已知的两种DBI工具DynamoRIO和Pin都是基于这样的框架的，只是两者在实现细节和优化方法上存在不同。</p><p><img src="./image/DBI_framework.png" alt="DBI_framework"></p><p>这里的DBI tool就是用户自定义的插桩工具，在DynamoRIO中被称为client，在Pin中被称为Pintool。</p><p>用户可以在DBI tool中定义插桩点，插桩指令以及在什么时候进行插桩。插桩指令中包含用于监视或者修改目标进程的回调函数(callback function)，比如上图在一个基本块的末尾插入一条对bb_callback()函数的回调，然后bb_callback()就对这个基本块进行分析或者修改。</p><blockquote><p>基本块(basic block)：是一组直线代码序列，除了基本块入口与出口没有其他的分支跳转。</p></blockquote><p>首先，用户需要向DBI引擎注册这个DBI tool，这样DBI引擎才能够找到用户在DBI tool中定义的插桩规则，注册完成后DBI 引擎将会启动目标进程；随后code fetcher会从目标进程中提取一段代码；instrumentation engine会按照DBI tool中定义的规则对这段代码进行插桩；已插桩的代码将由JIT(Just-In-Time) compiler 进行优化，并重写代码的控制流，保证控制流不会跳转到未插桩的代码执行而丢失对目标进程的跟踪；这里的JIT编译器与其他场景下(Java, C#)的JIT编译器不同，这里的JIT编译器的作用主要是优化机器码，相当于是将机器码转换成机器码。</p><p>经过插桩和JIT编译后的代码将会被存放在code cache中执行，以便已插桩的代码能够被重用而无需每次都让instrumentation engine进行插桩操作。当遇到的控制流指令要求获取新的代码时，将会重新进行code fetch的工作。</p><p>code cache中的大部分指令都是直接运行，但对于某些指令，DBI引擎可能会对其进行模拟而不是直接执行。</p><h3 id="Overview">Overview</h3><p>这部分的内容主要是对DynamoRIO的大致框架进行介绍，主要的参考内容是官方文档中Build Your Own Tool -&gt; Tool Event Model and API，内容包括DynamoRIO的事件类型以及常用API。</p><h4 id="Common-events">Common events</h4><p>DynamoRIO中提供了一些client可以拦截的特定事件，如果在client中定义了事件拦截函数，那么当这个事件触发时，DynamoRIO将会调用client中定义的事件拦截函数，这就是client与DynamoRIO交互的基本模式。</p><p>常见的事件有下面几种：</p><ul><li>基本块以及trace的生成和删除，当DynamoRIO中获取或者删除一个基本块或者trace时触发，dr_register_bb_event(), dr_register_bb_event(), dr_register_trace_event(), dr_register_delete_event()</li><li>进程的初始化和退出，当目标进程开始执行和退出时触发，dr_client_main(), dr_register_exit_event()</li><li>线程的初始化和退出，当目标进程中有创建线程或者线程退出时触发，dr_register_thread_init_event(), dr_register_thread_exit_event()</li><li>系统调用拦截，当目标进程执行一个系统调用之前或之后，或者由数字过滤的系统调用时触发，dr_register_pre_syscall_event(), dr_register_post_syscall_event(), dr_register_filter_syscall_event()</li></ul><p>这里只介绍了几种经常会用到的事件，上面所出现的函数就是DynamoRIO提供的API，通过这些API，用户可以在client中定义当触发这些事件时应该回调哪个函数，这些API都是以一个函数指针作为参数。</p><p>通常，client需要在DynamoRIO提供的API，dr_client_main() ，中对所需要的事件进行注册，也就是指定相应拦截事件的回调函数，这样当这些事件发生时DynamoRIO就会调用回调函数进行处理。所以 dr_client_main() 也相当于是每个client的程序入口点。每个可拦截事件都有对应的API指定拦截该事件的回调函数，比如 dr_register_thread_init_event() 接口用于指定拦截线程初始化事件的回调函数，当目标进程初始化一个线程时，DynamoRIO将会调用指定的回调函数。</p><p>DynamoRIO中也提供了一些用于解注册的API，用于取消某个事件与对应的回调函数的绑定关系。</p><p>需要注意的是，DynamoRIO允许同一个事件与多个回调函数关联，但是DynamoRIO不会统合这多个回调函数的接口，而需要client自行处理好多个回调函数的适应性。</p><p>在头文件 dr_events.h 中定义了所有的注册接口和解注册接口。</p><p>DynamoRIO也向用户提供了强大的实用程序库，用户可以借由这个程序库实现运行时的代码转换。这些接口在 dr_tools.h 和 dr_proc.h 中定义。</p><h4 id="Code-Manipulation-API">Code Manipulation API</h4><p>DynamoRIO的主要功能就在其代码修改API中体现，代码修改API向用户提供了观察和修改应用所执行的代码流的方法。这部分的内容主要参考官方文档的Build Your Own Tool -&gt; Code Manipulation API。这里所说的代码修改将不局限于蹦床，即插入跳转指令以转移应用的控制流，而是任意的修改。</p><h5 id="指令的表示">指令的表示</h5><p>在介绍DynamoRIO中用于修改代码的API之前，需要先了解DynamoRIO中是如何表示代码的。</p><p>在DynamoRIO中，使用数据结构 instr_t 来代表一条指令，而数据结构 instrlist_t 则是一个指令链表，在头文件 dr_instr.h 和 dr_instrlist.h 中定义这两种数据结构开放的接口，也就是能够对这两种数据结构进行操作的函数。需要注意的是，这两种数据结构对于client来说都是不透明的，也就是用户在定义插桩工具时并不会知道 instr_t 和 instrlist_t 这两个数据结构的内部成员，也就无法对其进行直接操作。</p><p>在后面的内容中将会看到，client通常会以基本块(basic block)或者trace的形式与 instrlist_t 进行交互。正如前面所提到的，基本块就是一个以控制转移操作结束的指令序列。而trace则是应用程序频繁执行的基本块序列，也可称为 hot code，这个是由DynamoRIO在应用程序运行时动态生成的。在DynamoRIO中会将基本块和trace统称为代码片段(fragments)，用以展示应用程序控制流的线性视图。</p><p>可以使用 instr_create() 或者宏命令 INSTR_CREATE_* 和 XINST_CREATE_* 创建了一条指令，那么这条指令所占用的堆空间将会在该指令被加入某个 instrlist_t 结构中或者trace事件时由DynamoRIO自动释放。而如果用户创建这条指令有其他的目的，那么需要调用 instr_destroy() 来手动释放这条指令所占用的堆空间。</p><h5 id="事件">事件</h5><p>在前面已经提到过，用户与DynamoRIO交互的主要方式是通过触发可拦截的事件来调用cilent定义的回调函数（在DynamoRIO中这个回调函数也会被称为事件钩子,event hook），从而让用户得以在应用运行期间执行相应的操作。前面所提到的内容主要是介绍如何向DynamoRIO注册可拦截事件的回调函数，或者说是事件钩子，而这里将会介绍如何定义这样的回调函数。</p><p>DynamoRIO中提供了两个与应用代码片段相关的事件，一个用于基本块，使用 dr_register_bb_event() 来注册该事件的回调函数；另一个用于trace，使用dr_register_trace_event() 来注册该事件的回调函数。当创建代码片段时，DynamoRIO将会调用相应的事件钩子，所以client能够检查并修改DynamoRIO发送的指令。使用基本块的事件钩子，client能够看到应用程序所执行的所有指令；使用trace的事件钩子，client能够对频繁执行的代码路径进行插桩。</p><blockquote><p>从前面的DBI框架中能够看出，触发代码片段创建事件的时间点是当代码被放入代码缓存中的时间点，在DynamoRIO中，这个时间点被称为转换时间(transformation time)，只有在这个时间点client才能够对应用程序的代码进行检查或修改；而代码缓存中的代码被重复执行的时间点在DynamoRIO中则是被称为执行事件(execution time)。</p></blockquote><p>通过 dr_register_bb_event() 注册的基本块创建事件对应的事件钩子可以有下面几个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dr_emit_flags_t</span> <span class="hljs-title function_">new_block</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext, </span><br><span class="hljs-params">                          <span class="hljs-type">void</span> *tag, </span><br><span class="hljs-params">                          <span class="hljs-type">instrlist_t</span> *bb,</span><br><span class="hljs-params">                          <span class="hljs-type">bool</span> for_trace, <span class="hljs-type">bool</span> translating)</span>;<br></code></pre></td></tr></table></figure><p>这些参数的含义如下：</p><ul><li><em>drcontext</em> 是一个指向应用程序的机器上下文的指针，而client不应该应用程序的上下文，所以这个指针以 void * 的类型进行传递，这个参数是为了DynamoRIO中那些其他需要访问应用程序内部状态的API所提供的；</li><li><em>tag</em> 是一个基本块的唯一标识符；</li><li><em>bb</em> 指向基本块所包含的指令的指令链表，client能够通过这个指针检查、修改甚至是完全替换这个链表中的指针；</li><li><em>for_trace</em> 用于表示这个事件钩子只针对新创建的基本块(false) 还是将该基本块添加到一个正在创建的trace中(true)；</li><li><em>translating</em> 用于表示这个事件钩子在基本块创建时触发(false)还是在地址转换时触发(true)；</li></ul><p>事件钩子的返回类型必须是 dr_emit_flags_t 类型的。</p><p>为了遍历一个 instrlist_t 链表中的指令，可以使用 instrlist_first(), instrlist_last() 以及 instr_get_next() 接口，比如下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dr_emit_flags_t</span> <span class="hljs-title function_">new_block</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext, <span class="hljs-type">void</span> *tag, <span class="hljs-type">instrlist_t</span> *bb,</span><br><span class="hljs-params">                          <span class="hljs-type">bool</span> for_trace, <span class="hljs-type">bool</span> translating)</span><br>&#123;<br>  <span class="hljs-type">instr_t</span> *instr, *next;<br>  <span class="hljs-keyword">for</span> (instr = instrlist_first(bb);<br>       instr != <span class="hljs-literal">NULL</span>;<br>       instr = next) &#123;<br>    next = instr_get_next(instr);<br>    <span class="hljs-comment">/* do some processing on instr */</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> DR_EMIT_DEFAULT;<br>&#125;<br></code></pre></td></tr></table></figure><p>在DynamoRIO中，插入到应用程序的指令可以分为两类，一类是将会被作为应用程序行为的一部分的指令，这类指令被称为应用指令(application instruction)；另一类添加的指令本质上是观察性的而不会代表应用程序的行为，这类指令被称为元指令(meta instruction)。可以使用下面的API来创建元指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">instr_set_meta();<br>instrlist_meta_preinsert();<br>instrlist_meata_postinsert();<br>instrlist_meta_append();<br></code></pre></td></tr></table></figure><p>需要注意的是客户端将它不想被视为应用程序指令的任何控制流指令标记为元指令。 这样做会通知 DynamoRIO 这些指令应该在本地执行，而不是被捕获并重定向到新的基本块片段。</p><p>元指令通常是可观察的，在这种情况下元指令不应该出错，并且translating字段应该是空的。当然也有可能会使用故意造成错误的元指令，或者因为访问应用程序的内存空间而出错的元指令，但是client必须要能够处理这些错误，关于错误处理的内容将会在介绍状态转换时介绍。</p><p>如果使用 instr_get_next() 或者 instrlist_first() 来遍历指令链表，那么元指令也是可见的，如果想要只遍历应用指令(non-meta)，那么需要使用下面的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">instr_get_next_app();<br>instrlist_first_app();<br></code></pre></td></tr></table></figure><p>在DynamoRIO中有一个严格的模型，这个模型将应用指令的分析过程和插桩指令的插入过程分割开来，在Multi-instrumentation Manager插件中实现了这个模型。</p><p>通过 dr_register_trace_event() 注册的trace创建事件对应的事件钩子可以有下面几个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">dr_emit_flags_t</span> <span class="hljs-title function_">new_trace</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext, <span class="hljs-type">void</span> *tag, <span class="hljs-type">instrlist_t</span> *trace,</span><br><span class="hljs-params">                          <span class="hljs-type">bool</span> translating)</span>;<br></code></pre></td></tr></table></figure><p>这里除了 <em>tag</em> 参数用以唯一标记一个trace以外，其他参数的含义和前面介绍的基本块事件钩子的参数的含义是一致的。</p><p>这里再次强调，DynamoRIO会在每个代码片段创建的时候调用该事件对应的事件钩子，也就是当代码被提交到代码缓存区之前才会调用事件钩子。</p><p>组成trace的基本块在插入到代码缓存区之前会被缝合到一起。此外，如果基本块创建对应的事件钩子的 <em>for_trace</em> 参数被设为 true 的话，每当组成trace的基本块被添加时，DynamoRIO也会调用基本块创建事件对应的事件钩子。所以如果想要保留对于基本块的插桩，那么client需要根据 <em>for_trace</em> 参数采取相同的行动。因此，如果目标是对所有代码进行插桩，那么完全可以忽略trace事件。</p><p>如果client只是添加不引用应用程序内存的插桩指令(meta instruction)，并且没有对应用程序的指令进行修改，那么就不需要考虑保存应用程序的状态；然而，如果client需要修改应用程序的指令或者添加可能出错的指令，那么client需要能够恢复应用程序的上下文。每当DynamoRIO需要将代码缓存的上下文转换成为应用程序原来的上下文时，将会调用由 dr_register_restore_state_event() 或者 dr_register_restore_state_ex_event() 注册的事件钩子。</p><p>这两个事件对应的事件钩子将会接受下面的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">restore_state</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext, <span class="hljs-type">void</span> *tag, <span class="hljs-type">dr_mcontext_t</span> *mcontext,</span><br><span class="hljs-params">                   <span class="hljs-type">bool</span> restore_memory, <span class="hljs-type">bool</span> app_code_consistent)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">restore_state_ex</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext, <span class="hljs-type">bool</span> restore_memory,</span><br><span class="hljs-params">                      <span class="hljs-type">dr_restore_state_info_t</span> *info)</span><br></code></pre></td></tr></table></figure><p>后面在讨论应用程序的状态恢复时将会详细介绍。</p><p>当DynamoRIO删除一个代码片段时，也会调用由 dr_register_delete_event() 注册的事件钩子，这个事件钩子可以接受下面的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fragment_deleted</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext, <span class="hljs-type">void</span> *tag)</span>;<br></code></pre></td></tr></table></figure><p>如果client中维护了一个关于已发射代码的数据结构，那么这个数据结构需要在代码片段被删除时保持一致。</p><h5 id="指令的解码和生成">指令的解码和生成</h5><p>前面介绍了DynamoRIO中用以检查和修改应用程序代码的一些接口，而这部分内容将会介绍如何解码或者创建一条指令。</p><p>在DynamoRIO中指令解码最常用的API就是 decode() 函数，这个函数会将指令相关的所有信息，包括操作数和操作码，填充到传递给该函数的 instr_t 数据结构中。</p><p>在对指令进行解码时，需要用户手动管理 instr_t 数据结构的内存，在下面的例子中，使用 instr_init(), instr_reset() 以及 instr_free() 方法来对一个 instr_t 数据结构进行初始化，重置以及释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">instr_t</span> instr;<br>instr_init(&amp;instr);<br><span class="hljs-keyword">do</span> &#123;<br>  instr_reset(dcontext, &amp;instr);<br>  pc = decode(dcontext, pc, &amp;instr);<br>  <span class="hljs-comment">/* check for invalid instr */</span><br>  <span class="hljs-keyword">if</span> (pc == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">if</span> (instr_writes_memory(&amp;instr) <span class="hljs-comment">/* return true if instr is a memory-reference instruction */</span>) &#123;<br>    <span class="hljs-comment">/* do some processing */</span><br>  &#125;<br>&#125; <span class="hljs-keyword">while</span> (pc &lt; stop_pc);<br>instr_free(dcontext, &amp;instr);<br></code></pre></td></tr></table></figure><p>decode() 函数的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">DR_API byte* <span class="hljs-title function_">decode</span><span class="hljs-params">(<span class="hljs-type">void</span> * drcontext,</span><br><span class="hljs-params">byte * pc,</span><br><span class="hljs-params"><span class="hljs-type">instr_t</span> * instr )</span><br></code></pre></td></tr></table></figure><p>该函数会将参数 <em>pc</em> 所指向的地址的指令信息填充到参数 <em>instr</em> 所指向的 instr_t 数据结构中。</p><p>DynamoRIO中提供了两种从头生成新指令的方法：</p><p>#1. 使用宏命令 INSTR_CREATE_* 来创建，这个宏命令会自动使用隐式操作数</p><p><code>instr_t *instr = INSTR_CREATE_dec(dcontext, opnd_create_reg(REG_EDX));</code></p><p>#2. 使用指明操作码和所有操作数的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">instr_t</span> *instr = instr_create(dcontext);<br>instr_set_opcode(instr, OP_dec);<br>instr_set_num_opnds(dcontext, instr, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>instr_set_dst(instr, <span class="hljs-number">0</span>, opnd_create_reg(REG_EDX));<br>instr_set_src(instr, <span class="hljs-number">0</span>, opnd_create_reg(REG_EDX));<br></code></pre></td></tr></table></figure><p>使用第二种方法时，操作数的顺序和大小必须和DynamoRIO使用的模板保持一致。而创建指令的宏命令在 dr_ir_macros.h 中定义。</p><h5 id="实用程序">实用程序</h5><p>除了指令的解码和生成，DynamoRIO中还提供了一些高层次的插桩工具，包含下面的内容：</p><ul><li>插入一个对用户定义函数的clean call；</li><li>对控制转移指令的插桩；</li><li>将应用程序的寄存器内容溢出到DynamoRIO线程专用溢出槽；</li><li>快速保存和恢复算术标识(arithmetic flags)</li></ul><p>下面将会对这些功能进行详细的介绍。</p><h6 id="Clean-call">Clean call</h6><p>为了能够更轻松地在应用程序指令流中插入指令，DynamoRIO中提供了一种 clean call 机制，这个机制能够让用户在应用程序执行流中插入一条对 client 函数的透明调用(transparent call)。这个机制会处理好切换到干净的堆栈，为调用设置参数并进行调用，可选择保留浮点状态，并在整个序列中保留应用程序状态。DynamoRIO中的 dr_insert_clean_call() 接口能够实现这种机制，下面是一个例子，用于插入一条指向函数 at_mbr() 的clean call：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (instr_is_mbr(instr)) &#123;<br>  app_pc address = instr_get_app_pc(instr);<br>  uint opcode = instr_get_opcode(instr);<br>  <span class="hljs-type">instr_t</span> *nxt = instr_get_next(instr);<br>  dr_insert_clean_call(drcontext, ilist, nxt, (<span class="hljs-type">void</span> *) at_mbr,<br>                       <span class="hljs-literal">false</span><span class="hljs-comment">/*don&#x27;t need to save fp state*/</span>,<br>                       <span class="hljs-number">2</span> <span class="hljs-comment">/* 2 parameters */</span>,<br>                       <span class="hljs-comment">/* opcode is 1st parameter */</span><br>                       OPND_CREATE_INT32(opcode),<br>                       <span class="hljs-comment">/* address is 2nd parameter */</span><br>                       OPND_CREATE_INTPTR(address));<br>&#125;<br></code></pre></td></tr></table></figure><p>DynamoRIO为clean call切换的栈空间会比较小，可以使用运行时选项 -stack_size 来指定栈空间的大小。此外，DynamoRIO会分析每个clean call的被调用目标，并且尝试减少上下文切换的大小，如果被调用者足够简单，则会自动内联该函数。</p><h6 id="状态保存">状态保存</h6><p>有时候插桩代码的执行需要使用到寄存器来保存运算数，为了不破坏应用程序的正常执行，需要在执行插桩代码之前保存要使用到的寄存器的内容，然后再在插桩代码执行完成后恢复寄存器原来的内容。在DynamoRIO中可以使用下面的函数来保存和恢复应用程序的寄存器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">dr_save_reg();<br>dr_restore_reg();<br>dr_reg_spill_slot_reg();<br></code></pre></td></tr></table></figure><p>对于长期持久性，也就是保存生命周期更长的变量，DynamoRIO 还提供了一个通用的专用线程本地存储字段供client使用，从而使client能够更轻松的实现一些线程感知的功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">dr_get_tls_field();<br>dr_set_tls_field();<br></code></pre></td></tr></table></figure><p>如果要在插桩代码中执行算数运算，那么在执行插桩代码之前也需要保存当前的算法标识寄存器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">dr_save_arith_flags();<br>dr_restore_arith_flags(); <br></code></pre></td></tr></table></figure><p>后面给出的例子中可以看到在实现DBI工具时需要注意应用程序的状态保存。</p><h4 id="Multi-Instrumentation-Manager">Multi-Instrumentation Manager</h4><p>前面提到过，在DynamoRIO中有一个严格的模型，这个模型将应用指令的分析过程和插桩指令的插入过程分割开来，DynamoRIO建议用户定义的插桩工具都按照这个模型来开发，而Multi-Instrumentation Manager(drmgr)插件则是这个模型的实现。</p><p>在使用这个插件之前需要先调用 drmgr_init() 函数，并在程序退出之前调用 drmgr_exit() 函数。此外，为了提供对回调事件的排序控制，drmgr 插件中替换了 DynamoRIO中的大部分事件，而这些事件大部分都只是将 “dr_” 前缀替换成 “drmgr_” 前缀。</p><p>drmgr 将代码分为下面四个类别：</p><ol><li>application-to-application: 修改应用程序自身的代码，试图影响应用程序的行为或者性能；</li><li>instrumentation insertion: 在应用程序的代码之间插入的用于监视的插桩代码；</li><li>instrumentation-to-instrumentation: 通常是用于优化全套插桩代码的代码；</li><li>meta-instrumentation: 通常是用于对插桩代码进行调试的代码；</li></ol><p>而 instrumentation insertion 又可以分为两个阶段：应用程序代码（这里是指在原始的代码进行修改后的代码）的分析阶段，然后是然后是插入插桩代码的阶段，一次插入一条指令。</p><p>因此，整个插桩流程依次分为下面5个阶段：</p><ol><li>application-to-application transformation</li><li>application code analysis</li><li>instrumentation insertion, one instruction at a time</li><li>instrumentation-to-instrumentation transformation</li><li>meta-instrumentation transformation</li></ol><p>向 drmgr 注册的每个组件都可以注册五个阶段中的部分或全部。 在每个阶段，都会调用每个注册组件的回调。</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* the first stage, application-to-application transformation, for bb event */</span><br>DR_EXPORT <span class="hljs-type">bool</span> <span class="hljs-title function_">drmgr_register_bb_app2app_event</span><span class="hljs-params">(<span class="hljs-type">drmgr_xform_cb_t</span> func,</span><br><span class="hljs-params">                                                 <span class="hljs-type">drmgr_priority_t</span> * priority </span><br><span class="hljs-params">                                              )</span>;<br><span class="hljs-comment">/* the second and third stage, application code analysis and instrumentation insertion, for bb event */</span><br>DR_EXPORT <span class="hljs-type">bool</span> <span class="hljs-title function_">drmgr_register_bb_instrumentation_event</span><span class="hljs-params">(<span class="hljs-type">drmgr_analysis_cb_t</span> analysis_func,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_insertion_cb_t</span> insertion_func,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_priority_t</span> * priority </span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">/* the forth stage, instrumentation-to-instrumentation transformation, for bb event */</span><br>DR_EXPORT <span class="hljs-type">bool</span> <span class="hljs-title function_">drmgr_register_bb_instru2instru_event</span><span class="hljs-params">(<span class="hljs-type">drmgr_xform_cb_t</span> func,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_priority_t</span> * priority </span><br><span class="hljs-params">                                                    )</span>;<br><span class="hljs-comment">/* the fifth stage, meta-instrumentation transformation, for bb event */</span><br>DR_EXPORT <span class="hljs-type">bool</span> <span class="hljs-title function_">drmgr_register_bb_meta_instru_event</span><span class="hljs-params">(<span class="hljs-type">drmgr_xform_cb_t</span> func,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_priority_t</span> * priority </span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">/* register the first four stage for bb event */</span><br>DR_EXPORT <span class="hljs-type">bool</span> <span class="hljs-title function_">drmgr_register_bb_instrumentation_ex_event</span><span class="hljs-params">(<span class="hljs-type">drmgr_app2app_ex_cb_t</span> app2app_func,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_ilist_ex_cb_t</span> analysis_func,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_insertion_cb_t</span> insertion_func,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_ilist_ex_cb_t</span> instru2instru_func,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_priority_t</span> * priority </span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">/* registers callbacks for all five instrumentation stage at once */</span><br>DR_EXPORT <span class="hljs-type">bool</span> <span class="hljs-title function_">drmgr_register_bb_instrumentation_all_events</span><span class="hljs-params">(<span class="hljs-type">drmgr_instru_events_t</span> * events,</span><br><span class="hljs-params"><span class="hljs-type">drmgr_priority_t</span> * priority )</span>;<br></code></pre></td></tr></table></figure><p>这样能够将不同类型的插桩类型分为一组，并且假设后续的插桩类型并不使对当前插桩阶段的分析或操作无效。</p><p>需要注意的是insturmentation insertion阶段每次处理一条指令，对于应用程序中的每一条指令都需要调用相应的call函数进行插桩。这样的处理方式能够简化寄存器分配，寄存器分配由另一个插件 drreg 提供。</p><h3 id="Sample-tools">Sample tools</h3><p>这里将会以演示如何开发一个自定义的插桩工具。</p><h4 id="Instruction-Count">Instruction Count</h4><p>这里将会开发一个用以计数控制转移指令的工具。在这个DBI工具中，我们将要跟踪三个计数器：num_direct_calls, num_indirect_calls, num_returns来计数三种不同类型的控制转移指令，并且我们会同时追踪全局的计数器和线程私有的计数器。</p><p>首先，需要在dr_client_main()接口中进行初始化，这个接口是所有DBI工具的入口点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">DR_EXPORT <span class="hljs-type">void</span><br><span class="hljs-title function_">dr_client_main</span><span class="hljs-params">(<span class="hljs-type">client_id_t</span> id, <span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-comment">/* register events */</span><br>  dr_register_exit_event(event_exit);<br>  dr_register_thread_init_event(event_thread_init);<br>  dr_register_thread_exit_event(event_thread_exit);<br>  dr_register_bb_event(event_basic_block);<br> <br>  <span class="hljs-comment">/* make it easy to tell, by looking at log file, which client executed */</span><br>  dr_log(<span class="hljs-literal">NULL</span>, DR_LOG_ALL, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Client &#x27;countcalls&#x27; initializing\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们在 dr_client_main() 函数中注册一些事件钩子，这些注册函数都是以一个函数指针作为参数，一些用于初始化数据结构，一些用于程序退出时输出统计结果并释放内存空间，而其中的 dr_register_bb_event() 函数用于注册执行插桩的事件钩子。</p><p>为了追踪线程私有的计数器，需要先定义下面的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> num_direct_calls;<br>  <span class="hljs-type">int</span> num_indirect_calls;<br>  <span class="hljs-type">int</span> num_returns;<br>&#125; <span class="hljs-type">per_thread_t</span>;<br></code></pre></td></tr></table></figure><p>在后面的用于执行插桩钩子将会看到具体是如何统计这些线程私有数据的。</p><p>现在，需要在线程相关的事件钩子中为每个线程初始化这样的数据结构，并在每个线程退出时展示这些数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">event_thread_init</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext)</span><br>&#123;<br>  <span class="hljs-comment">/* create an instance of our data structure for this thread */</span><br>  per_thread *data = (per_thread *)<br>    dr_thread_alloc(drcontext, <span class="hljs-keyword">sizeof</span>(per_thread));<br>  <span class="hljs-comment">/* store it in the slot provided in the drcontext */</span><br>  dr_set_tls_field(drcontext, data);<br>  data-&gt;num_direct_calls = <span class="hljs-number">0</span>;<br>  data-&gt;num_indirect_calls = <span class="hljs-number">0</span>;<br>  data-&gt;num_returns = <span class="hljs-number">0</span>;<br>  dr_log(drcontext, DR_LOG_ALL, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;countcalls: set up for thread &quot;</span>TIDFMT<span class="hljs-string">&quot;\n&quot;</span>,<br>         dr_get_thread_id(drcontext));<br>&#125;<br> <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">event_thread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext)</span><br>&#123;<br>  per_thread *data = (per_thread *) dr_get_tls_field(drcontext);<br> <br>  ... <span class="hljs-comment">// string formatting and displaying</span><br> <br>  <span class="hljs-comment">/* clean up memory */</span><br>  dr_thread_free(drcontext, data, <span class="hljs-keyword">sizeof</span>(per_thread));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这段代码中，需要注意两个接口就是 dr_set_tls_field() 和 dr_get_tls_field() 接口。</p><p>在官方文档中的 API reference 目录下，可以找到这些接口的详细描述。当然可以直接在DynamoRIO首页的搜索框里直接搜索这些接口。</p><p><code>dr_set_tls_field(void *drcontext, void *value)</code>：用于在应用程序中设置一块由 client 控制的TLS区域。</p><p><code>dr_get_tls_field(void *drcontext)</code>: 用于返回由 client 控制的TLS区域。</p><p>需要注意的是，插桩工具只是在应用程序中插入适当的指令，而这些指令的执行还是由应用程序来完成的，所以如果想要存储长期的数据，需要在应用程序的内存空间中找到一块区域来存储。</p><p>用于执行插桩的事件钩子中，将会向应用程序中的适当位置插入相应的代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">dr_emit_flags_t</span><br><span class="hljs-title function_">event_basic_block</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext, <span class="hljs-type">void</span> *tag, <span class="hljs-type">instrlist_t</span> *bb,</span><br><span class="hljs-params">                  <span class="hljs-type">bool</span> for_trace, <span class="hljs-type">bool</span> translating)</span><br>&#123;<br>  <span class="hljs-type">instr_t</span> *instr, *next_instr;<br> <br>  ... <span class="hljs-comment">// some logging</span><br> <br>  <span class="hljs-keyword">for</span> (instr = instrlist_first(bb); instr != <span class="hljs-literal">NULL</span>; instr = next_instr) &#123;<br>    <span class="hljs-comment">/* grab next now so we don&#x27;t go over instructions we insert */</span><br>    next_instr = instr_get_next(instr);<br> <br>    <span class="hljs-comment">/* instrument calls and returns -- ignore far calls/rets */</span><br>    <span class="hljs-keyword">if</span> (instr_is_call_direct(instr)) &#123;<br>      insert_counter_update(drcontext, bb, instr,<br>                            offsetof(<span class="hljs-type">per_thread_t</span>, num_direct_calls));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr_is_call_indirect(instr)) &#123;<br>      insert_counter_update(drcontext, bb, instr,<br>                            offsetof(<span class="hljs-type">per_thread_t</span>, num_indirect_calls));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr_is_return(instr)) &#123;<br>      insert_counter_update(drcontext, bb, instr,<br>                            offsetof(<span class="hljs-type">per_thread_t</span>, num_returns));<br>    &#125;<br>  &#125;<br> <br>  ... <span class="hljs-comment">// some logging</span><br> <br>  <span class="hljs-keyword">return</span> DR_EMIT_DEFAULT;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码就是基本块事件对应的事件钩子代码，前面介绍过，如果想要检查应用程序的每条指令，那么可以使用基本块事件的事件钩子。</p><p>在上面的代码中，将会使用一个 for 循环对基本块中的每一条指令进行检查，然后判断这条指令是什么类型，DynamoRIO提供了一些接口用于判断这条指令的类型，比如 <code>instr_is_call_direct(instr)</code>  用于判断 <em>instr</em> 所代表的指令是否是一条直接调用的指令。如果是，那么就在由 client 控制的 TLS 区域的数据结构中将对应的计数器加一，这个过程的实现是在应用程序中插入一条代码让应用程序在执行 <em>instr</em> 所代表的直接调用指令之前先将相应的计数器加一。</p><p>下面的代码演示了如何在应用程序中插入一条这样的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">insert_counter_update</span><span class="hljs-params">(<span class="hljs-type">void</span> *drcontext, <span class="hljs-type">instrlist_t</span> *bb, <span class="hljs-type">instr_t</span> *where, <span class="hljs-type">int</span> offset)</span><br>&#123;<br>  <span class="hljs-comment">/* Since the inc instruction clobbers 5 of the arithmetic eflags,</span><br><span class="hljs-comment">   * we have to save them around the inc. We could be more efficient</span><br><span class="hljs-comment">   * by not bothering to save the overflow flag and constructing our</span><br><span class="hljs-comment">   * own sequence of instructions to save the other 5 flags (using</span><br><span class="hljs-comment">   * lahf) or by doing a liveness analysis on the flags and saving</span><br><span class="hljs-comment">   * only if live.</span><br><span class="hljs-comment">   */</span><br>  dr_save_arith_flags(drcontext, bb, where, SPILL_SLOT_1);<br> <br>  <span class="hljs-comment">/* Increment the global counter using the lock prefix to make it atomic</span><br><span class="hljs-comment">   * across threads. It would be cheaper to aggregate the thread counters</span><br><span class="hljs-comment">   * in the exit events, but this sample is intended to illustrate inserted</span><br><span class="hljs-comment">   * instrumentation.</span><br><span class="hljs-comment">   */</span><br>  instrlist_meta_preinsert(bb, where, LOCK(INSTR_CREATE_inc<br>    (drcontext, OPND_CREATE_ABSMEM(((byte *)&amp;global_count) + offset, OPSZ_4))));<br> <br>  <span class="hljs-comment">/* Increment the thread private counter. */</span><br>  <span class="hljs-keyword">if</span> (dr_using_all_private_caches()) &#123;<br>    <span class="hljs-type">per_thread_t</span> *data = (<span class="hljs-type">per_thread_t</span> *) dr_get_tls_field(drcontext);<br>    <span class="hljs-comment">/* private caches - we can use an absolute address */</span><br>    instrlist_meta_preinsert(bb, where, INSTR_CREATE_inc(drcontext,<br>        OPND_CREATE_ABSMEM(((byte *)&amp;data) + offset, OPSZ_4)));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">/* shared caches - we must indirect via thread local storage */</span><br>    <span class="hljs-comment">/* We spill xbx to use a scratch register (we could do a liveness</span><br><span class="hljs-comment">     * analysis to try and find a dead register to use). Note that xax</span><br><span class="hljs-comment">     * is currently holding the saved eflags. */</span><br>    dr_save_reg(drcontext, bb, where, REG_XBX, SPILL_SLOT_2);<br>    dr_insert_read_tls_field(drcontext, bb, where, REG_XBX);<br>    instrlist_meta_preinsert(bb, where,<br>        INSTR_CREATE_inc(drcontext, OPND_CREATE_MEM32(REG_XBX, offset)));<br>    dr_restore_reg(drcontext, bb, where, REG_XBX, SPILL_SLOT_2);<br>  &#125;<br> <br>  <span class="hljs-comment">/* restore flags */</span><br>  dr_restore_arith_flags(drcontext, bb, where, SPILL_SLOT_1);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这里需要执行算术操作，所以在插入的增加计数器的指令前面还需要插入一条用以保存算术标识寄存器的指令，然后再在插入的增加计数器的指令后面插入一条恢复算术标识寄存器的指令，使用下面的API来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">DR_API <span class="hljs-type">void</span> <span class="hljs-title function_">dr_save_arith_flags</span><span class="hljs-params">(<span class="hljs-type">void</span> * drcontext,</span><br><span class="hljs-params"><span class="hljs-type">instrlist_t</span> * ilist,</span><br><span class="hljs-params"><span class="hljs-type">instr_t</span> * where,</span><br><span class="hljs-params"><span class="hljs-type">dr_spill_slot_t</span> slot )</span>;<br>DR_API <span class="hljs-type">void</span> <span class="hljs-title function_">dr_restore_arith_flags</span><span class="hljs-params">(<span class="hljs-type">void</span> * drcontext,</span><br><span class="hljs-params"><span class="hljs-type">instrlist_t</span> * ilist,</span><br><span class="hljs-params"><span class="hljs-type">instr_t</span> * where,</span><br><span class="hljs-params"><span class="hljs-type">dr_spill_slot_t</span> slot )</span>;<br></code></pre></td></tr></table></figure><p>从而避免应用程序执行增加计数器的指令会对本身的指令执行产生影响。</p><p>使用 DynamoRIO 提供的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">DR_API <span class="hljs-type">void</span> <span class="hljs-title function_">instrlist_meta_preinsert</span><span class="hljs-params">(<span class="hljs-type">instrlist_t</span> * ilist,</span><br><span class="hljs-params"><span class="hljs-type">instr_t</span> * where,</span><br><span class="hljs-params"><span class="hljs-type">instr_t</span> * instr )</span>;<br></code></pre></td></tr></table></figure><p>可以在 <em>ilist</em> 指定的指令列表的 <em>where</em> 处的前面插入一条指令，这条指令由参数 <em>instr</em> 指定。</p><p>而前面介绍过，可以有两种方法创建指令，一种是直接使用宏命令进行创建，一种是指定操作码和操作数的方式创建。两种方法其实都一样，这里使用宏命令来创建增加计数器的指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INSTR_CREATE_inc(dc, d)instr_create_1dst_1src((dc), OP_inc, (d), (d))</span><br></code></pre></td></tr></table></figure><p>这样的宏命令相当于直接指定了操作码，用户在使用这个宏命令时只需要提供 drcontext 和操作数，即可创建一条将操作数加一的指令。</p><p>而这里使用下面的宏命令来创建操作数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPND_CREATE_ABSMEM (addr, size)opnd_create_rel_addr(addr, size)</span><br></code></pre></td></tr></table></figure><p>这条宏命令将创建一个由地址指定的操作数，为了提供地址，我们首先拿到数据结构的地址作为基地址，然后再在基地址上加上计数器的偏移量，从而将数据结构中相应的计数器的作为操作数。因为这里的计数器是 int 类型的，所以操作数的大小应该是为4(OPSZ_4)。</p><p>完整的代码可以在  <a href="https://github.com/DynamoRIO/dynamorio/tree/master/api/samples/countcalls.c">countcalls.c</a> 这里。</p><p>自此，我们创建好了一个插桩工具，现在只需要对这个工具进行编译即可，而DynamoRIO中工具编译的方法可以在 <a href="https://dynamorio.org/page_build_client.html">How to Build a Tool</a> 文档中找到。在下载了DynamoRIO后，在samples目录下还可以找到一些自带的插桩工具，这些工具在下载下来的时候就已经编译好了，可以在samples/bin64/中找到编译好的工具。</p><p>而如果我们想再添加一个新的插桩工具，最好是将源码放在DynamoRIO中的samples 目录下，然后在该目录下的 CMakeLists.txt 中添加add_sample_client()；然后在该目录下创建一个 build 目录用以执行 cmake，cmake 会自动创建 makefile，所以进入 build目录执行cmake:</p><p><code>cmake -DDynamoRIO_DIR=~/DynamoRIO/cmake ../</code></p><p>这里的 “DDynamoRIO_DIR” 是指DynamoRIO中cmake目录的路径，然后上面的命令会为samples 中的每一个插桩工具生成一个makefile，所以只需要在 build 目录下输入: <code>make instrace_test</code> 就可以自动编译我们添加的名为 “instrace_test” 的插桩工具。</p><p>编译好的工具在build/bin目录中可以找到。</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quantitative analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>simpleperf_notes</title>
    <link href="/2022/10/14/simpleperf-notes/"/>
    <url>/2022/10/14/simpleperf-notes/</url>
    
    <content type="html"><![CDATA[<h2 id="SimplePerf-Notes">SimplePerf Notes</h2><p>这个博客是在学习使用SimplePerf来监视测试机在运行测试程序时的访存请求总数以及缓存缺失数时所记录的笔记。</p><p>SimplePerf是一种CPU分析器(Profiler)，可以用于监测测试程序运行时的性能数据，而本人需要使用测试机的实测缓存访问结果来验证缓存仿真器的仿真结果。这个博客将会记录SimplePerf的基本用法以及一些底层的原理。</p><p>在将SimplePerf的统计结果与缓存仿真器的仿真结果进行比对已验证缓存仿真器的可靠性之前，需要验证一点，或者说必须确保的是，也就是SimplePerf的结果确实是实测所得的结果，体现在下面几个方面：</p><ul><li>SimplePerf工具本身是没有问题的？</li><li>SimplePerf的用法是没有问题的？</li><li>SimplePerf的结果统计分析过程是没有问题的？也就是对SimplePerf的输出结果的解释是准确的？</li></ul><p>这个博客所记录的问题就是为了确保上面几点是能够成立的。</p><h3 id="PMU">PMU</h3><p>SimplePerf需要PMU(Performance Monitor Unit)的支持，本人所使用的测试机处理器型号为Cortex A75，因此这里所记录的PMU相关内容是Cortex A75处理器中的PMU相关内容。</p><p>这部分的内容参考自ARM手册。</p><p>处理器中的PMU能够允许用户收集到各种运行时的内核(Core)以及内存系统相关的操作统计信息，PMU中包含六个计数器，每个计数器能够用于统计处理器中已有的任何事件相关的统计信息。由于管道效应，记录的绝对计数可能会有所不同，除了在很短的时间内启动计数器的情况外，这个问题的所带来的影响是可以忽略的。</p><p>PMU中包含下面的接口与计数器：</p><ul><li>Event Interface: 来自整个处理器设计中的其他单元向PMU提供的事件接口</li><li>System register and APB interface: 可以使用系统寄存器或外部 APB 接口对 PMU 寄存器进行编程</li><li>Counters: 32-bit 的事件寄存器，这些事件寄存器会在根据事件递增，此外还有一个64-bit 的时钟寄存器</li><li>PMU register interface: Cortex A57支持从内部系统寄存器接口和内存映射接口访问PMU寄存器</li></ul><p>这里介绍几个本人需要使用得到的PMU事件，完整的事件列表可以在<a href="https://developer.arm.com/documentation/100403/0301/debug-descriptions/performance-monitor-unit/pmu-events?lang=en">PMU Events</a>中找到：</p><ol><li><p>SW_INCR: 体系架构已执行的指令，也就是条件检查已通过的指令总数</p></li><li><p>L1D_CACHE: L1data cache的访问总数，这个事件会对L1 data cache的读，写以及<strong>预取</strong>请求进行计数，这<em>包括尚未具有可缓存性属性的不可缓存推测性读取</em></p></li><li><p>L1D_CACHE_REFILL: L1 data cache重填充次数，这个事件会记录所有对L1 数据缓存的缓存分配，这包括读取行填充(linefill)，存储(store)行填充，以及预取行填充</p><p>重填充(refill)计数器：会将所有导致重填充的内存读取或者写入操作进行计数，这些请求会导致L1数据缓存从下面的位置重新填充：另一块L1数据缓存、L2缓存以及任何其他级别的缓存或者主存，换句话说，也就是L1数据访问所导致的缺失。</p></li><li><p>L1D_CACHE_REFILL_INNER: 计数器对造成L1D_CACHE_REFILL的每个访问进行计数，这些访问导致缓存通过直接集群内部的另一个缓存传输来实现重填充</p></li><li><p>L1D_CACHE_REFILL_OUTER: 计数器对造成L1D_CACHE_REFILL的每个访问进行计数，这些访问导致缓存通过直接集群外部的另一个缓存传输来实现重填充</p></li></ol><p>需要注意的是，这里的内部和外部之间的边界是由具体实现所定义的，不一定和其他类似的边界有关联，比如inner cacheable和outer cacheable的边界。</p><h4 id="Cache-controller">Cache controller</h4><p>在ARM Cortex-A系列的处理器中，包含一个缓存控制器(Cache Controller)的硬件模块，这个硬件模块对于应用程序是不可见的。缓存控制器会自动将代码或者数据从主存写入到缓存中。缓存控制器会接受来自处理器内核的内存读写请求然后对缓存或者外部内存执行必要的操作。</p><p><em>在缓存控制器执行操作之前，需要先确认访存请求的地址是否是可缓存的(Cacheable)</em>，只有当访存请求的地址被标记为可缓存的，缓存控制器才会执行缓存查找(Cache lookup)的操作。</p><p>缓存查找就是检查是否能够在缓存中找到这个请求的地址，缓存查找的具体方法是通过比对请求地址中的某一部分比特与缓存中行相关联的tag值，如果能够匹配，并且缓存行被标记为有效的，则缓存命中，那么读写请求都在缓存中进行。</p><p>如果在缓存中没有找到与请求地址相匹配的tag，或者对应的缓存行是无效的，则缓存缺失，缓存缺失会导致这个请求进一步传递到存储层次结构中的下一级，比如L2缓存或者外部内存。缓存缺失也会导致一个<strong>缓存行填充</strong>(cache linefill)，缓存行填充会导致将一块主内存的内容复制到缓存中。同时，请求的数据或指令被流式传输到内核(streamed to the core)。同样的，缓存行填充的过程对于应用程序是透明的。</p><p>需要注意的是，在缓存行填充的过程中，<strong>处理器内核并不需要等到数据被写入到缓存后，也就是缓存行填充执行完成后，才能使用数据</strong>。缓存控制器通常会首先访问缓存行内的关键字(critical word)。比如现在要加载一条指令，而这个读指令的请求导致了缓存缺失，并从而导致缓存行填充，处理器内核会首先会检查缓存行中包含请求数据的那部分，然后关键字会被直接供应到处理器内核流水线，而缓存硬件和外部总线接口随后在后台读取缓存行的其余部分。</p><h3 id="SimplePerf">SimplePerf</h3><p>SimplePerf是安卓对于Linux中的Perf工具的替代品，这个工具需要linux内核支持和PMU的硬件支持。</p><p>SimplePerf的整体框架如下图所示：4</p><p><img src="./image/how_simpleperf_works.png" alt="how_simpleperf_works"></p><p>前面已经讨论过了SimplePerf的PMU硬件支持，所以这里将会对SimplePerf的内核支持进行介绍。</p><p>在操作系统内核中使用Perf事件驱动(perf event driver)来桥接用户空间与PMU驱动器(pmu drivers)。Perf事件驱动的主要功能是将PMU事件映射到Perf事件类型，然后向用户空间提供一个接口以罗列当前可支持的Perf事件，以及监视已选线程性能的系统调用(“perf_event_open()”)。</p><p>PMU驱动器需要在Perf事件驱动器中进行注册，包含下面几种PMU驱动器：</p><ul><li>CPU PMU驱动器：该驱动器用于操作PMU硬件设备，位于/drivers/perf目录下</li><li>软件PMU驱动器：用以统计CPU时钟，内存页错误之类的事件</li><li>tracepoint PMU驱动器：用以统计类似sched:sched_switch之类的事件</li><li>设备特定的PMU驱动器</li></ul><p>对于用户空间，SimplePerf将其功能划分为子命令(Subcommands)：</p><ul><li>list command: 用以列举设备上可用的Perf事件</li><li>stat command: 监视线程，然后打印事件计数器的值</li><li>record command: 监视线程，然后使用采样生成分析数据(profile data)文件，这个文件命名为perf.data，无法直接查看文件的内容</li><li>report command: 报告由record命令生成的分析数据文件</li></ul><p>SimplePerf中的stat命令执行原理如下如所示：</p><p><img src="./image/simpleperf_stat.png" alt="simpleperf_stat"></p><p>从上图可以看到，SimplePerf会根据stat命令的参数调用perf_event_open()系统调用来监视执行的线程以及perf事件，随后内核将会启动相应事件的计数器，等到统计的时间结束后，SimplePerf可以读取相应perf事件文件描述符(perf event file descriptors)的计数器的值。</p><p>SimplePerf中另一个比较常用的命令是record，record命令能够提供更加详细的分析数据，所以这个命令相较于stat命令也更加复杂，下图是record命令的执行原理：</p><p><img src="./image/simpleperf_record.png" alt="simpleperf_record"></p><p>同样的，SimplePerf首先会根据record命令的参数调用perf_event_open()系统调用来监视执行的线程以及perf事件，随后内核将启动相应的事件计数器，与stat不同的是，此时SimplePerf中会调用mmap()函数来创建一个与内核共享的循环缓冲区，从而避免因为计数寄存器溢出而导致的数据丢失。当事件计数器产生溢出后，创建一个采样record，然后将其放入到循环缓冲区中。最后，SimplePerf中使用多线程的方式来读取结果：使用read record线程从循环缓冲区中读取采样record，然后将读取到的结果传递给主线程，而在主线程中手机辅助信息，并将最终的结果写入到分析数据文件中。</p><p>record命令可以使用的选项，这里只记录了一些常用的选项：</p><ol><li><p>‘-p pid1,pid2,…’：记录已存在的进程的perf事件</p></li><li><p>‘-t tid1,tid2,…’：记录已存在的线程的perf事件</p></li><li><p>-a：记录全系统的perf事件</p></li><li><p>–cpu cpu_item1,cpu_item2,…：只记录已选择的CPU上的相关信息，这个选项的参数是十进制，从0开始编号。</p><p>这里需要注意与taskset的差别，taskset锁核命令所接受的参数是16进制，参数的每一位代表一个核。</p></li><li><p>-e event1[:modifier1],event2[:modifier2],…：选择需要统计的perf事件，modifier有两种可选项：</p><ol><li>u - 只监视用户空间的事件</li><li>k - 只监视内核空间的事件</li></ol></li></ol><p>在使用事件修饰符时，需要注意的一点是，对于同一个事件，如果只统计该事件用户空间的计数器，那么report的结果中会将内核部分的占比标记为unknown；如果同时统计该事件用户空间和内核空间的计数器，那么report的结果中会将内核部分的占比标记出来，通常内核部分的占比所属的shared object字段使用方括号进行标记。</p><p>执行完record命令后，SimplePerf将会生成分析数据文件，这个文件无法直接读取，需要使用report命令来解析这个文件中的统计数据。</p><p>如果想要了解每个子命令可接受的选项的话，可以使用 ‘simpleperf help (subcommands)’ 来查看该子命令所有可接受的选项。</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quantitative analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>syscall_notes</title>
    <link href="/2022/10/13/syscall-notes/"/>
    <url>/2022/10/13/syscall-notes/</url>
    
    <content type="html"><![CDATA[<h2 id="Syscall-Notes">Syscall Notes</h2><p>在计算机中，系统调用是一种编程方式，计算机程序通过该方式向操作系统的内核请求服务。系统调用是一种计算机程序与操作系统互动的方式：计算机程序通过系统调用向操作系统内核请求服务，而系统调用则会通过API(Application Program Interface)向用户程序提供操作系统的服务。</p><p>系统调用提供了进程和操作系统之间的接口，以允许用户级进程请求操作系统的服务。系统调用是内核系统的唯一入口点， 所有需要资源的程序都必须通过系统调用获取相应资源。</p><h3 id="关于中断">关于中断</h3><p>ref. 《汇编语言》(第4版，王爽著)</p><p><em>任何一种通用的CPU都必须具备一种能力，即可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理</em>。</p><p>这种特殊的信息就是所谓的中断(Interrupt, sometimes refered to as trap)信息，<u>中断信息会使CPU不再继续从刚执行完的指令向下执行，而是转而去处理这个特殊的信息</u>。中断信息会要求CPU马上进行某种处理，并向所要进行的该种处理提供了必备的参数的通知信息。</p><p>中断信息可以来自CPU的内部或者外部，来自CPU内部的中断信息通常被称为<strong>内中断</strong>，来自CPU外部（外设，比如键盘）的中断信息通常被称为<strong>外中断</strong>，这里主要介绍内中断。</p><h4 id="内中断的产生">内中断的产生</h4><p>CPU一般会在下面几种情况下产生内中断：</p><ol><li>除法错误</li><li>单步执行</li><li>执行into指令</li><li>执行int指令</li></ol><p>在讨论各种中断的具体含义之前，需要先了解中断信息是如何让CPU区分不同的类型的中断信息的。</p><p>CPU首先需要知道的是所接收到的中断信息的来源，即中断源，因此中断信息中必须包含识别来源的编码。一般使用中断类型码来标识中断信息的来源。</p><p>比如在8086CPU中，上面中断来源在中断类型码为：除法错误：0；单步执行：1；执行into指令：4；执行int指令，int指令的格式为 int n，其中n为一个立即数，就是提供给CPU的中断类型码。</p><h4 id="中断向量表">中断向量表</h4><p>除了中断源，CPU还需要知道如何处理中断，而这由中断处理程序决定，也就是让CPU接收到中断信息后转而去执行该中断信息对应的中断处理程序。</p><p>因此CPU需要某种方式获取到对应中断处理程序的入口地址。而<u>中断向量表就是为了让CPU知道各种中断处理程序的入口地址</u>。所谓<strong>中断向量其实就是中断处理程序的入口地址，中断向量表中存储了各类中断信息所对应的中断向量</strong>。</p><p>中断向量表通常位于内存中的某个预定的位置，比如在8086CPU中，中断向量表指定放在内存地址0处，从内存0000:0000到0000:03FF 的1024个单元中存放这中断向量表。</p><p>所以，CPU在接收到中断信息后，会根据中断类型码找到该中断的中断向量，并设置程序计数器到该中断向量，从而处理该中断。</p><h4 id="中断过程">中断过程</h4><p>在CPU执行完中断处理程序后，需要返回到原来的地址继续执行，所以在中断过程中设置程序计数器之前，还需要将程序计数器原来的值保存起来。</p><p>比如在8086CPU中，CPU收到中断信息后，所引发的中断过程如下：</p><ol><li>从中断信息中读取中断类型码</li><li>将标志寄存器入栈，因为下一步就要修改标志寄存器的值，所以这里需要先保存原来的值</li><li>设置标志寄存器的第8位TF和第9位IF的值为0</li><li>保存当前程序计数器的值</li><li>从中断向量表中读取该类型中断对应的中断向量，并设置程序计数器的值为该中断向量</li></ol><p>从中断处理程序回到原来执行的地址则需要使用<code>iret</code>指令，该指令的功能用汇编语法描述为：<code>pop PC; pop flag</code>，也就是恢复程序计数器，然后恢复标志寄存器原来的值。</p><h3 id="Linux系统调用">Linux系统调用</h3><p>ref. <a href="https://linux-kernel-labs.github.io/refs/heads/master/index.html">linux kernel labs</a></p><p>类似于函数库中的API，系统调用是内核向高层(high level)用户应用提供的服务。</p><p><img src="./image/Linux_syscall.png" alt="linux_syscall"></p><p>然后，实际上系统调用与常规的函数调用有很大的区别，系统调用是用于完成下列任务的特定的汇编指令：</p><ul><li>设置相关信息以识别系统调用以及参数</li><li>触发内核模式的切换</li><li>收集系统调用执行的结果</li></ul><p>在Linux上，系统调用由系统调用号进行识别，系统调用最多只能接受6个参数。系统调用号和系统调用的参数都是通过指定的寄存器进行传递。</p><p>比如在X64的机器上，RAX用于传递系统调用号，而系统调用的6个参数从左到右则分别由%rdi, %rsi, %rdx, %r10, %r8, %r9这几个寄存器进行传递。</p><p>系统函数库(e.g.: libc)提供了一些实现系统调用的函数，从而使用户应用能够更方便地使用系统调用。</p><p>当发生用户到内核模式的转换时，用户应用执行流程将会被中断并被转移到内核入口点。系统调用入口点将寄存器（其中包含来自用户空间的值，包括系统调用号和系统调用参数）保存在堆栈上，然后继续执行系统调用调度程序(system call dispatcher)。</p><p><img src="./image/syscall_control_flow.png" alt="syscall_control_flow"></p><p>系统调用调度程序所完成的任务主要是检查系统调用号，然后调用对应的内核函数。下面的代码演示了系统调用掉程序的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Handles int $0x80 */</span><br>__visible <span class="hljs-type">void</span> <span class="hljs-title function_">do_int80_syscall_32</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    enter_from_user_mode();<br>    local_irq_enable();<br>    do_syscall_32_irqs_on(regs);<br>&#125;<br><br><span class="hljs-comment">/* simplified version of the Linux x86 32bit System Call Dispatcher */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">do_syscall_32_irqs_on</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr = regs-&gt;orig_ax;<br><br>    <span class="hljs-keyword">if</span> (nr &lt; IA32_NR_syscalls)<br>        regs-&gt;ax = ia32_sys_call_table[nr](regs-&gt;bx, regs-&gt;cx,<br>                                           regs-&gt;dx, regs-&gt;si,<br>                                           regs-&gt;di, regs-&gt;bp);<br>    syscall_return_slowpath(regs);<br>&#125;<br></code></pre></td></tr></table></figure><p>在X86 32bit的机器上，系统调用号使用EAX寄存器传递，而系统调用的6个参数则分别通过EBX, ECX, EDX, ESI, EDI, EBP寄存器传递。</p><p>系统调用表就是系统调用调度器用以将系统调用号映射到内核函数的工具。</p><p>下面的代码演示了系统调用表的原理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_I386(nr, sym, qual) [nr] = sym,</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">sys_call_ptr_t</span> ia32_sys_call_table[] = &#123;<br>  [<span class="hljs-number">0</span> ... __NR_syscall_compat_max] = &amp;sys_ni_syscall,<br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/syscalls_32.h&gt;</span></span><br>&#125;;<br><br><span class="hljs-comment">// some system calls</span><br>__SYSCALL_I386(<span class="hljs-number">0</span>, sys_restart_syscall, )<br>__SYSCALL_I386(<span class="hljs-number">1</span>, sys_exit, )<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_32</span><br>__SYSCALL_I386(<span class="hljs-number">2</span>, sys_fork, )<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>__SYSCALL_I386(<span class="hljs-number">2</span>, sys_fork, )<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>__SYSCALL_I386(<span class="hljs-number">3</span>, sys_read, )<br>__SYSCALL_I386(<span class="hljs-number">4</span>, sys_write, )<br></code></pre></td></tr></table></figure><p>内核在执行系统调用对应的内核函数时，需要对用户传递来的参数进行处理。因为这些参数都是从用户空间传递过来的，内核无法假设这些参数的正确性，所以必须对其进行彻底的验证。</p><p>参数的验证是有必要的，因为系统调用是在内核模式下执行的，所以系统调用在执行期间是能够访问内核空间的，比如对于参数中的指针，必须检查下面两种情况：</p><ul><li>不允许指向内核空间的指针</li><li>检查指针是否是有效的</li></ul><p>这里之所以不能允许用户应用传递指向内核空间的指针作为参数，是因为内核模式下执行的系统调用接受这样的参数可能会导致意料之外的错误。</p><p>比如，用户应用调用一个read()或者write()系统调用，如果传递的指针是指向内核空间的，那么系统调用的执行可能会read()系统调用读取一个文件后对内核空间的内存造成污染。</p><p>同样的，如果用户应用传递的指针是无效的，也就是未映射的，或者对只读区域进行写操作，那么会导致内核崩溃。</p><h4 id="Virtual-Dynamic-Shared-Object-VDSO">Virtual Dynamic Shared Object(VDSO)</h4><p>这项技术是为了对部分系统调用进行加速，具体做法是内核会生成一段用于启动系统调用的指令，这些指令会被格式化为ELF共享目标，并映射到用户空间结束的地址。libc在需要调用系统调用时，将会从VDSO中搜索相关系统调用，并使用其中的指令启动系统调用。</p><p>VDSO技术包含虚拟系统调用(Virtual System Call, vsyscalls)，之所以称其为虚拟系统调用是因为这些虚拟系统调用能够直接在用户空间运行。vsyscall也是VDSO中的一部分，它们能够从VDSO的内存页中访问数据，这些数据要么是静态的，要么是由内核在VDSO内存区域中的单独的读写映射区域(separate read-write map)中修改的。</p><p>通常使用/proc/self/map文件读取到的目标进程的内存映射中，除了目标进程对应的二进制文件的映射区域，堆区域，栈区域以及目标进程所依赖的共享目标的映射区域以外，还包含另外三个额外的区域: “vdso”, “vsyscall”, “vvar”，如下：</p><p><img src="./image/process_maps.png" alt="process_maps"></p><p>这三个额外的区域就是为了VDSO技术是映射的内存区域，其中&quot;vdso&quot;就是前面提到的由内核生成的用于启动系统调用的指令，被格式化为ELF共享目标，和普通的代码段一样，执行权限是&quot;RX&quot;。“vsyscall&quot;就是虚拟系统调用所使用的内存映射区域，可以看到这块区域的执行权限是&quot;X”，也就是用户应用无法直接访问这块区域，但是这块区域中存放着可执行的代码，&quot;vvar&quot;就是vsyscall与VDSO进行数据交互所使用的内存映射区域，执行权限为只读的。</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb_usage</title>
    <link href="/2022/10/12/gdb-usage/"/>
    <url>/2022/10/12/gdb-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="GDB-basic-usage">GDB basic usage</h2><p>ref. <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">GDB User Manual</a></p><p>GDB是一个功能十分强大的调试工具，对于二进制分析工作非常有用。这里记录GDB的一些常见用法，如果想要了解关于GDB使用的详细信息，可以参考GDB用户手册。</p><h3 id="Get-in-and-out-of-GDB">Get in and out of GDB</h3><p>这里先介绍如何启动GDB，可以直接在命令行中输入gdb即可启动gdb。一旦启动gdb，gdb将会从命令行中读取命令直到退出。如果想要退出，那么可以输入命令q, exit 或者直接ctrl + d 以退出。</p><p>通常都会在启动gdb时指定一个可执行文件: <code>gdb [program]</code></p><p>或者也可以让gdb挂载到一个正在运行中的程序: <code>gdb -p [pid]</code> 或者 <code>gdb attach [pid]</code></p><blockquote><p>通常查看运行中的程序的方式三种：</p><p>#1. 第一种方法是使用 pidof 命令进行查看，这也是最方便的一种方法，需要注意的是在命令行中是可以通过反引号进行命令的嵌套的，比如先要让gdb挂载到一个名为 host 的程序上，那么可以直接使用: gdb attach `pidof host`</p><p>#2. 第二种方法，如果是在命令行中启动目标程序，那么可以在命令后面加上一个 &amp; 符号，那么shell在执行目标程序之前就会先打印出目标进程的pid。</p><p>#3. 第三种方法是使用ps 查看当前正在执行的所用进程。</p></blockquote><p>如果想要在GDB中执行shell命令那么，可以通过以下的方法执行shell命令：</p><p><code>shell [comman-string]</code>，或者</p><p><code>![command-string]</code></p><p>这在使用gdb调试查看目标进程的内存空间分布(cat /proc/&lt;pid&gt;/maps)时非常有用。</p><p>如果想要将gdb命令的输出通过管道作为shell命令的输入的话，那么可以使用下面的命令：</p><p><code>pipe [command] | [shell_command]</code>，或者</p><p><code>|[command] | [shell_command]</code></p><p>可以使用gdb变量$_shell_exitcode以及$_shell_exitsignal来检查上一次通过shell或者pipe命令执行的shell命令的退出状态。</p><p>如果想要了解gdb中某个命令的使用方法，可以在gdb中输入help命令来获取帮助，也可以使用<code>help [command]</code> 来了解某个gdb命令的使用方法。</p><h3 id="Running-Programs-Under-GDB">Running Programs Under GDB</h3><p>在GDB中，可以直接使用命令 <code>run</code> 或者 <code>r</code> 启动目标程序。</p><p>如果指定目标程序的命令行参数，环境变量，工作目录以及标准输入输出，那么可以用下面的方法在运行程序之前指定这些选项：</p><ul><li>命令行参数：在GDB中，可以将 <code>run</code> 指令的参数作为目标程序的命令行参数，或者使用 <code>set args</code> 命令来设置命令行参数</li><li>环境变量：可以使用GDB命令<code>set environment</code> 或者 <code>set env</code> 来设置环境变量，然后使用 <code>unset environment</code> 或者 <code>unset env</code> 命令来取消环境变量，比如使用命令 <code>set env VARNAME = value</code> 就会设置一个名为 “VARNAME” 取值为 “value” 的环境变量</li><li>工作目录：可以使用GDB命令 <code>set cwd</code> 来指定工作目录，如果没有指定工作目录，将会继承GDB的工作目录</li><li>标准输入输出：目标程序的标准输入输出和GDB的标准输入输出是在同一个设备上进行的，也就是说目标程序的输出和GDB的输出会在同一个终端上显示，也可以在执行 <code>run</code> 指令时重定向输入和输出，例如<code>run &gt; outputfile</code> 就可以将目标程序的输出重定向到outputfile文件中。</li></ul><p>需要注意的是，虽然能够在GDB中进行标准输入输出的重定向，但是不能够使用管道将目标程序的输出传递到另一个程序中。如果尝试这样做，GDB可能会调试另一个程序，而不是你想要调试的目标程序。</p><p>如果想要检查这些选项的信息，那么可以使用GDB中的 <code>info</code> 或者 <code>show</code> 命令来查看。</p><p>其中 <code>info</code> 指令用于描述程序的状态。比如，可以使用 <code>info args</code> 来查看传递给函数的参数，也可以使用 <code>info registers</code> 来列出当前正在使用的寄存器的值，或者使用 <code>info breakpoints</code> 来查看设置了哪些断点。如果想要了解 <code>info</code> 指令的更多用法，可以使用 <code>help info</code> 进行查看。</p><p>而相较于 <code>info</code> 指令，<code>show</code> 指令则是用于描述GDB自身的状态，可以使用 <code>show</code> 命令来查看所有由 <code>set</code> 指令所设置的选项，比如 <code>show env</code> 来查看设置的环境变量。</p><p>如果想要查看所有可以使用 <code>set</code> 命令设置的选项，那么可以使用不带参数的<code>show</code> 命令或者 <code>info set</code> 来查看，这两个命令的输出都是一样的。</p><h3 id="Stopping-and-Continuing">Stopping and Continuing</h3><p>在GDB中有三种情况可以让程序停止运行：</p><ol><li>breakpoint: 当程序运行到设置断点的地址后，将会停止运行；</li><li>watchpoint: 当某个表达式的值改变时，程序会停止运行，这种断点有时也被称为数据断点；</li><li>catchpoint: 当发生某种类型的事件时，程序会停止运行，比如程序抛出某个exception或者加载共享库时；</li></ol><p>这三种断点需要使用不同命令来进行设置。</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo basic usage</title>
    <link href="/2022/10/12/hexo-basic-usage/"/>
    <url>/2022/10/12/hexo-basic-usage/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
